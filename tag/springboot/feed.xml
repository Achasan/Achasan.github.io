<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://achasan.github.io/tag/springboot/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://achasan.github.io/" rel="alternate" type="text/html" />
  <updated>2022-01-02T21:03:48+09:00</updated>
  <id>https://achasan.github.io/tag/springboot/feed.xml</id>

  
  
  

  
    <title type="html">Memory Repo. | </title>
  

  
    <subtitle>by Achasan</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">HTTP 기본 지식 : 쿠키(Cookie)</title>
      <link href="https://achasan.github.io/http_basic_7" rel="alternate" type="text/html" title="HTTP 기본 지식 : 쿠키(Cookie)" />
      <published>2021-11-02T00:00:00+09:00</published>
      <updated>2021-11-02T00:00:00+09:00</updated>
      <id>https://achasan.github.io/http_basic_7</id>
      <content type="html" xml:base="https://achasan.github.io/http_basic_7">&lt;h1 id=&quot;http-웹-기본-지식-7&quot;&gt;HTTP 웹 기본 지식 7&lt;/h1&gt;

&lt;h2 id=&quot;쿠키&quot;&gt;쿠키&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Set-Cookie: 서버에서 클라이언트로 쿠키를 전달한다.(응답)&lt;/li&gt;
  &lt;li&gt;Cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청 시 서버로 전달한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;쿠키는 어떤 상황에서 사용되는지 아래 사진을 보고 확인해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-17-15-50.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 쿠키를 사용하지 않았을 때의 상황이다. POST 방식으로 /login URI에 user를 홍길동으로 하는 요청을 클라이언트에서 보냈을 때, 서버에서는 홍길동님이 로그인했다는 OK 응답메시지를 보내게 된다. “안녕하세요. 손님”이라는 문자를 출력한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-17-16-42.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;로그인이 된 것을 확인하고 /welcome 페이지로 이동했으나, 서버에서는 “안녕하세요, 손님”으로 메시지가 바꿔진 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;이유는 HTTP의 Stateless때문이다. 무상태 프로토콜이기 때문에 서버와 클라이언트가 요청을 주고받으면 연결이 끊어지게 되므로, 클라이언트가 서버에 욫어을 하면 서버는 이전 요청을 기억하지 못하게 되는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-17-19-49.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이를 해결하기 위해 클라이언트에서 GET을 통해 쿼리파라미터에 user=홍길동이라는 데이터를 넘겨서 “안녕하세요, 홍길동님”을 출력시키려고 한다. 과연 이것이 올바른 해결책이라고 할 수 있을까?&lt;/p&gt;

&lt;p&gt;이런 문제를 해결하기 위해서 쿠키라는 개념이 등장하였다. 이제 쿠키를 사용하여 로그인처리를 어떻게 하는지 사진으로 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-17-20-51.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클라이언트가 POST 방식으로 user=홍길동 이라는 메시지를 서버에 전송하면 서버는 Set-Cookie: user=홍길동 을 통해 쿠키를 클라이언트에 전송하는 것을 볼 수 있다. 클라이언트는 받은 쿠키를 쿠키 저장소에 저장하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-17-22-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다른 URI로 이동할 때 클라이언트는 서버에 쿠키를 전송한다. 쿠키를 받은 서버는 쿠키 데이터정보를 읽고, 비즈니스 로직을 처리하면서 홍길동이 로그인 되었다는 메시지를 출력하게된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;쿠키-1&quot;&gt;쿠키&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;set-cookie: sessionId=abcde1234; expires=Sat, 26-Dec-2020 00:00:00 GMT; path=/; domain=.google.com; Secure&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;쿠키의 사용처&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;사용자 로그인 세션 관리&lt;/li&gt;
      &lt;li&gt;광고 정보 트래킹(선호하는 광고가 어떤건지 체크)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;쿠키 정보는 항상 서버에 전송되는 것이 특징이다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;네트워크 트래픽을 추가적으로 유발한다.&lt;/li&gt;
      &lt;li&gt;따라서 최소한의 정보만 사용해야한다(세션 ID, 인증토큰 등)&lt;/li&gt;
      &lt;li&gt;서버에 전송하지않고 웹 브라우저 내부에 데이터를 저장하고 싶으면 웹 스토리지를 참고하는 것이 좋다(localStorage, sessionStorage)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;보안에 민감한 데이터는 저장해선 안된다(주민번호, 신용카드 등)&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;쿠키---생명주기&quot;&gt;쿠키 - 생명주기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Set-Cookie: &lt;strong&gt;expires&lt;/strong&gt;=Sat, 26-Dec-2020 04:39:21 GMT&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;만료일이 되면 쿠키가 삭제된다. (날짜를 기준으로 생명주기 설정)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Set-Cookie: &lt;strong&gt;max-age&lt;/strong&gt;=3600 (3600초)&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;0이나 음수를 지정하면 쿠키가 삭제된다. (시간을 기준으로 생명주기 설정)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;쿠키의 생명주기 종류는 2 가지가 있다. 세션쿠키는 만료 날짜를 생략하면 브라우저 종료 시 까지만 유지되는 쿠키이고, 영속 쿠키는 만료 날짜를 입력하면 해당 날짜까지 유지되는 생명주기이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;쿠키---도메인&quot;&gt;쿠키 - 도메인&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;domain=example.org&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;도메인을 명시하면 명시한 문서를 기준으로 도메인과 서브도메인을 포함하여 쿠키가 사용될 수 있다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;위의 예시를 기준으로 보면 example.org는 물론 dev.example.org도 쿠키 접근이 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;도메인을 생략하면 현재 문서 기준 도메인만 적용된다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;example.org에서 쿠키를 생성하고 domain 지정을 생략할 경우에는 example.org에서만 쿠키 접근이 가능하다. dev.example.org에서는 불가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;쿠키---경로&quot;&gt;쿠키 - 경로&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;path=/home&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;이 &lt;strong&gt;경로를 포함한 하위 경로 페이지만&lt;/strong&gt; 쿠키에 접근이 가능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;일반적으로 path=/ 루트로 지정한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;쿠키---보안&quot;&gt;쿠키 - 보안&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Secure : 쿠키는 http, https 구분하지 않고 전송하는데 Secure를 적용하면 https인 경우에만 전송한다.&lt;/li&gt;
  &lt;li&gt;HttpOnly : XSS 공격을 방지하기위해서 사용, JS에서 접근이 불가하다. HTTP 전송에만 사용된다.&lt;/li&gt;
  &lt;li&gt;SameSite : XSRF공격을 방지하고 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키를 전송한다.&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Achasan</name>
        
        
      </author>

      

      
        <category term="SpringBoot" />
      

      
        <summary type="html">HTTP 웹 기본 지식 7</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">HTTP 헤더 살펴보기(협상, 우선순위)</title>
      <link href="https://achasan.github.io/http_basic_6" rel="alternate" type="text/html" title="HTTP 헤더 살펴보기(협상, 우선순위)" />
      <published>2021-11-02T00:00:00+09:00</published>
      <updated>2021-11-02T00:00:00+09:00</updated>
      <id>https://achasan.github.io/http_basic_6</id>
      <content type="html" xml:base="https://achasan.github.io/http_basic_6">&lt;h1 id=&quot;http-웹-기본-지식-6&quot;&gt;HTTP 웹 기본 지식 6&lt;/h1&gt;

&lt;h2 id=&quot;http-헤더-자세히&quot;&gt;HTTP 헤더 자세히&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-12-45-06.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HTTP 헤더는 HTTP 전송에 필요한 모든 부가정보들을 담은 구역이라고 말했었다. HTTP 헤더의 자세한 구조를 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-12-46-49.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;헤더의-분류rfc2616-기준&quot;&gt;헤더의 분류(RFC2616 기준)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;General 헤더 : 메시지 전체에 적용되는 정보를 말한다. (Connection: close)&lt;/li&gt;
  &lt;li&gt;Request 헤더 : 요청 클라이언트의 정보를 말한다.(User-Agent: Mozilla/5.0 ..)&lt;/li&gt;
  &lt;li&gt;Response 헤더 : 응답 정보를 말한다. (Server: Apache)&lt;/li&gt;
  &lt;li&gt;Entity 헤더 : 엔티티 바디의 정보를 말한다. (Content-Type: text/html; charset=UTF-8, Content-Length: 3423)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-12-49-30.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메시지 본문(Message Body)는 엔티티 본문(entity body)을 전달하는데 사용한다.&lt;/li&gt;
  &lt;li&gt;엔티티 본문은 요청이나 응답에서 전달할 실제 데이터가 담겨있다.&lt;/li&gt;
  &lt;li&gt;엔티티 헤더는 엔티티 본문의 데이터를 해석할 수 있는 정보를 제공한다.
    &lt;ul&gt;
      &lt;li&gt;데이터 유형(html, json), 데이터 길이, 압축정보 등등을 제공한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;메시지 본문이 엔티티 본문을 포함한다고 보면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;원래는 이렇게 정의가 되어 있엇으나, &lt;strong&gt;2014년에 RFC7230~7235 개정판이 등장&lt;/strong&gt;하게 된다. 변경사항은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;엔티티(Entity)를 표현(Representation)으로 바꿈&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;여기서 Representation = Representation Metadata + Representation Data 를 말한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-12-54-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메시지 본문(message body)을 통해 표현 데이터를 전달하게된다.&lt;/li&gt;
  &lt;li&gt;여기서 메시지 본문을 페이로드(payload)라고 한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;표현은 요청이나 응답에서 전달할 실제 데이터&lt;/strong&gt;를 말한다.&lt;/li&gt;
  &lt;li&gt;또한 &lt;strong&gt;표현헤더는 표현 데이터를 해석할 수 있는 정보를 제공&lt;/strong&gt;한다.
    &lt;ul&gt;
      &lt;li&gt;데이터 유형(html, json), 데이터의 길이, 압축정보 등등을 제공한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;표현&quot;&gt;표현&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Content-Type: 표현 데이터의 형식
    &lt;ul&gt;
      &lt;li&gt;미디어 타입이나 문자 인코딩을 설명한다.&lt;/li&gt;
      &lt;li&gt;예) “text/html; charset=UTF-8”, “application/json”, “/assets/images/HTTP_images/png”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Content-Encoding: 표현 데이터의 압축 방식
    &lt;ul&gt;
      &lt;li&gt;표현한 데이터를 압축하기위해 사용한다.&lt;/li&gt;
      &lt;li&gt;데이터를 전달하는 곳에서 압축 후에 인코딩 헤더를 추가&lt;/li&gt;
      &lt;li&gt;데이터를 읽는 쪽에서 인코딩 헤더의 정보로 압축을 해제한다.&lt;/li&gt;
      &lt;li&gt;예) Content-Encoding: gzip&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Content-Language: 표현 데이터의 자연언어
    &lt;ul&gt;
      &lt;li&gt;표현 데이터의 자연 연어를 표현한다. (ko, en, en-US)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Content-Length: 표현 데이터의 길이. 바이트 단위이다.
    &lt;ul&gt;
      &lt;li&gt;Transfer-Encoding(전송코딩)을 사용하면 Content-Length를 사용해서는 안된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그렇다면 엔티티에서 표현으로 말고 단어를 바꾼 이유는 무엇일까? 표현이라는 단어를 사용하게 된 이유는 HTTP헤더에서 어떤 Content type으로 요청/응답을 하느냐에 따라 HTML로 표현될 지, JSON으로 표현될 지, image로 표현될 지가 달라지기 때문에 표현이라는 단어를 사용하게 된 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;협상컨텐츠-네고시에이션&quot;&gt;협상(컨텐츠 네고시에이션)&lt;/h2&gt;

&lt;p&gt;협상은 클라이언트가 선호하는 표현을 요청하는 것이다. 핵심적으로 사용되는 4가지가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Accept: 클라이언트가 선호하는 미디어 타입 전달&lt;/li&gt;
  &lt;li&gt;Accept-Charset: 클라이언트가 선호하는 문자 인코딩&lt;/li&gt;
  &lt;li&gt;Accept-Encoding: 클라이언트가 선호하는 압축 인코딩&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Accept-Language: 클라이언트가 선호하는 자연 언어&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;협상 헤더는 &lt;strong&gt;요청 시에만 사용&lt;/strong&gt;한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그렇다면 클라이언트가 선호하는 표현은 무엇이고, 협상이라는 것은 어디에 쓰이는 지 알아보자. 다음은 Accept-Language를 예로 들어 설명한 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-14-02-49.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;상황은 이렇다. 한국어 브라우저를 사용하는 클라이언트가 있고, 영어(기본)와 한국어를 지원하는 서버가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;클라이언트가 GET방식으로 /event URI가 있는 페이지를 요청한다.&lt;/li&gt;
  &lt;li&gt;서버는 클라이언트의 요청을 받는다. 클라이언트 측에서 따로 이야기한게 없었으므로 기본언어인 영어로 메시지 바디를 전송한다.&lt;/li&gt;
  &lt;li&gt;클라이언트는 한국어 브라우저를 사용하지만 영어로 작성된 페이지를 보게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;클라이언트는 한국어를 사용하기 때문에 한국어로 되어있는 페이지를 보길 원한다. 하지만 한국어로 페이지를 달라는 표현이 없었기 때문에 서버에서는 기본언어로 설정되있는 영어로 페이지를 보여주게 된다. 한국어를 원하는 클라이언트는 이제 다음과 같이 요청을 보낸다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-14-09-21.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Accept-Language: ko 라는 HTTP 헤더 정보를 넣어서 요청을 보냈다. 서버는 이를 읽으면 클라이언트 측에서 한국어를 사용한다는 것을 인지하고 한국어로 되어있는 HTML 페이지로 응답하게된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-14-10-58.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한 가지 더 생각해보자, 만약 서버에서 한국어를 지원하지 않고, 독일어(기본), 영어만 지원한다면 어떻게 될까? 기본언어가 독일어로 되어있지만 한국인은 그래도 영어로 홈페이지를 보는 것이 차라리 나을 것이다. 하지만 Accept-Language를 ko로 보내면 서버에서는 지원하는 언어가 없기 때문에 기본언어인 독일어를 보여주게 된다. 이럴 땐 어떻게 해야될까?&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;협상과-우선순위&quot;&gt;협상과 우선순위&lt;/h2&gt;

&lt;h3 id=&quot;quality-valuesq&quot;&gt;Quality Values(q)&lt;/h3&gt;

&lt;p&gt;Quality Values는 여러 옵션들 중에 우선순위를 정하는 값이라고 보면 된다. Quality Values의 범위는 0~1이고, 클수록 높은 우선순위를 갖는다. 만약 생략하면 자동으로 1로 할당되어진다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;우선순위는 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ko-KR;q=1 (q 생략됨)&lt;/li&gt;
  &lt;li&gt;ko;q=0.9&lt;/li&gt;
  &lt;li&gt;en-US;q=0.8&lt;/li&gt;
  &lt;li&gt;en;q=0.7&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-14-14-50.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우선순위를 이용해서 이제 위의 예시로 돌아가보자, 독일어보다는 영어가 나은 한국인 입장에서, Accept-Language에 우선순위를 정하면 서버에서는 독일어보다 영어를 선호하니 영어로 홈페이지를 불러오게 될 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;협상과-우선순위2&quot;&gt;협상과 우선순위2&lt;/h3&gt;

&lt;p&gt;위 처럼 Quality Values의 값을 할당하여 우선순위를 정할 수도 있다. 아니면 구체적인 명시를 통해서도 자동으로 우선순위가 정해지는 경우도 있다. 예시를 보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Accept: text/*, text/plain, text/plain;format=flowed, */*&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;text/plain;format=flowed&lt;/li&gt;
  &lt;li&gt;text/plain&lt;/li&gt;
  &lt;li&gt;text/*&lt;/li&gt;
  &lt;li&gt;*/*&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;우선순위는 구체적으로 쓴 순서대로이다. 1번부터4번 까지 봤을 때, 1번으로 갈 수록 보다 구체적으로 명시된 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;전송-방식&quot;&gt;전송 방식&lt;/h2&gt;

&lt;p&gt;전송 방식은 크게 네 가지가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;단순 전송: 말 그대로 따로 처리 과정을 거치지 않고 그대로 응답을 보낸다. 기본적으로 Content-Length를 포함하여 보낸다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;압축 전송: [Content-Encoding: gzip]과 같은 형태로 인코딩 압축하여 응답을 보내는 방식, 클라이언트에서 응답을 받으면 압축을 해제한 다음 데이터를 읽게 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;분할 전송: 데이터를 덩어리(chunked)로 나누어서 보내는 것을 말한다. Transfer-Encoding: chunked를 HTTP 헤더에 적어서 보낸다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;범위 전송: 클라이언트가 데이터를 받아가 중간에 끊겼을 때, 데이터를 다시 처음부터 끝까지 받는 것은 비효율적이므로 못받은 부분만 범위를 입력하여 요청을 보내면 서버가 범위만큼만 응답하여 데이터를 보내는 방식. Range: bytes=1001-2000과 같은 형식으로 보낸다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;일반-정보&quot;&gt;일반 정보&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;From: 유저 에이전트의 이메일 정보&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;일반적으로 잘 사용되지 않는다.&lt;/li&gt;
      &lt;li&gt;검색 엔진같은 곳에서 주로 사용한다.&lt;/li&gt;
      &lt;li&gt;요청에서 사용된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Referer: 이전 웹 페이지 주소&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;현재 요청된 페이지의 이전 웹 페이지 주소를 말한다.&lt;/li&gt;
      &lt;li&gt;A &amp;gt; B로 이동하는 경우 B를 요청할 때 Referer: A를 포함해서 요청한다.&lt;/li&gt;
      &lt;li&gt;요청에서 사용한다.&lt;/li&gt;
      &lt;li&gt;Referer같은 경우에는 포털사이트를 들어가서 f12를 누르고 Network에서 HTTP 메시지를 보면 바로 확인이 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;User-Agent: 유저 에이전트 애플리케이션 정보&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/
537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;클라이언트의 애플리케이션 정보(웹 브라우저 정보 등등)&lt;/li&gt;
      &lt;li&gt;통계 정보&lt;/li&gt;
      &lt;li&gt;어떤 종류의 브라우저에서 장애가 발생하는지 파악이 가능하다.&lt;/li&gt;
      &lt;li&gt;요청에서 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Server: 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Server: Apache/2.2.22(Debian)
server: nginx&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;응답에서 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Date: 메시지가 발생한 날짜와 시간&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Date: Tue, 15 Nov 1994 08:12:31 GMT&lt;/li&gt;
      &lt;li&gt;응답에서 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;특별한-정보&quot;&gt;특별한 정보&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-14-34-13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Host: 요청한 호스트의 정보(도메인)
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;요청에서 사용(필수값)&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;하나의 서버가 여러 도메인을 처리해야할 때 사용&lt;/li&gt;
      &lt;li&gt;하나의 IP주소에 여러 도메인이 적용되어 있을 때 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;호스트는 서버에서 가상 도메인을 활용하여 여러 개의 가상 호스트를 사용할 때, 어떤 호스트로 요청을 보내는 지를 서버가 구분할 때 필요하다. 요청에서의 필수값이므로 서버는 이 값을 보고 어떤 호스팅으로 보내야할 지를 판단하게된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Location: 페이지 리다이렉션
    &lt;ul&gt;
      &lt;li&gt;웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면 Location 위치로 자동이동하게 된다(리다이렉트) : 응답코드 3xx에서 설명한 바 있음&lt;/li&gt;
      &lt;li&gt;201 (Created) 상태코드의 경우 Location 값은 요청에 의해 생성된 리소스 URI이다.&lt;/li&gt;
      &lt;li&gt;3xx (Redirection): Location 값은 요청을 자동으로 리다이렉션하기 위한 대상 리소스를 가리킨다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Allow: 허용 가능한 HTTP 메서드
    &lt;ul&gt;
      &lt;li&gt;405 (Method Not Allowed)에서 응답에 포함해야한다.
        &lt;blockquote&gt;
          &lt;p&gt;Allow: GET, HEAD, PUT&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Retry-After: 유저 에이전트가 다음 요청을 하기까지 기다려야하는 시간&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;503(Service Unavailable) : 서비스가 언제까지 불능인지 알려줄 수 있다.&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;Retry-After: Fri, 31 Dec 1999 23:59:59 GMT (날짜 표기)&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;blockquote&gt;
          &lt;p&gt;Retry-After: 120 (초단위 표기)&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Authorization: 클라이언트 인증 정보를 서버에 전달하는 것&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Authorization: Basic xxxxxxxxxxx&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;WWW-Authenticate: 리소스 접근 시 필요한 인증 방법을 정의함
    &lt;ul&gt;
      &lt;li&gt;401 Unauthorized 응답과 함께 사용한다.
        &lt;blockquote&gt;
          &lt;p&gt;WWW-Authenticate: Newauth realm=”apps”, type=1, title=”Login to &quot;apps&quot;”, Basic realm=”simple”&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Achasan</name>
        
        
      </author>

      

      
        <category term="SpringBoot" />
      

      
        <summary type="html">HTTP 웹 기본 지식 6</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">HTTP 기본 지식 : 캐시(Cache)</title>
      <link href="https://achasan.github.io/http_basic_8" rel="alternate" type="text/html" title="HTTP 기본 지식 : 캐시(Cache)" />
      <published>2021-11-02T00:00:00+09:00</published>
      <updated>2021-11-02T00:00:00+09:00</updated>
      <id>https://achasan.github.io/http_basic_8</id>
      <content type="html" xml:base="https://achasan.github.io/http_basic_8">&lt;h1 id=&quot;http-웹-기본-지식-8&quot;&gt;HTTP 웹 기본 지식 8&lt;/h1&gt;

&lt;h2 id=&quot;캐시&quot;&gt;캐시&lt;/h2&gt;

&lt;p&gt;캐시를 사용하는 상황은 언제일까? 주로 브라우저의 이미지파일을 저장해놓고 해당 홈페이지를 로딩할 때 바로 리소스를 가져오도록 하기 위해서 사용될 것이다. 캐시를 사용해야하는 상황에 대해 사진으로 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-17-38-19.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;웹 브라우저가 star.jpg라는 이미지를 서버에 요청하면 서버는 star.jpg를 클라이언트에 전송할 것이다. 여기서 HTTP 헤더는 0.1MB, star.jpg는 1.0MB라고 가정해보자. 서버는 웹브라우저에게 총 1.1MB의 데이터를 전송하였고, 클라이언트는 성공적으로 웹페이지에 star.jpg를 출력했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-17-39-21.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클라이언트가 웹페이지를 탐색하다가 다시 star.jpg를 요청해야하는 상황이 되었다. 서버는 HTTP 요청 메시지를 읽고 다시 클라이언트에게 star.jpg파일을 전송한다. 1.1MB의 데이터가 다시 전송된다.&lt;/p&gt;

&lt;p&gt;뭔가 비효율적이다. 클라이언트에서 한번 받았던 데이터를 서버에서 매 번 전송을 해야하는 것은 자원낭비이다. 클라이언트 측에서 서버로부터 받은 데이터를 가지고 있으면서 서버에서 해당 데이터가 변경되지 않았으면 클라이언트가 가지고 있던 데이터를 다시 재활용하게 만드는 것이 캐시이다.&lt;/p&gt;

&lt;p&gt;캐시가 없다면 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야한다. 인터넷 네트워크 자원은 매우 느리고 비싸기 대문에 브라우저 로딩속도가 느려질 뿐 더러 사용자의 경험도 나빠진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-17-41-35.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번엔 캐시를 사용할 때 클라이언트가 star.jpg를 서버에 요청하는 상황이다. 서버는 클라이언트에 star.jpg를 넘겨준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-17-42-05.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클라이언트는 서버로부터 받은 star.jpg를 브라우저 캐시에 저장한다. 서버에서 정한 캐시 유효시간 데이터를 읽은 다음 그 시간동안 유효한 캐시데이터를 저장소에 저장한다.&lt;/p&gt;

&lt;p&gt;이후 브라우저는 star.jpg가 필요한 페이지에서 데이터를 확인하고 싶을 때 캐시 저장소에 있는 star.jpg를 불러와서 페이지에 출력하여 볼 수 있게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;캐시의-특징&quot;&gt;캐시의 특징&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.&lt;/li&gt;
  &lt;li&gt;비싼 네트워크 사용량을 줄일 수 있다.&lt;/li&gt;
  &lt;li&gt;브라우저 로딩 속도가 매우 빨라진다.&lt;/li&gt;
  &lt;li&gt;결과적으로 빠른 사용자 경험을 가질 수 있게 해준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그렇다면 캐시의 유효시간이 지났을 경우에는 어떻게 처리될까? 캐시 유효시간이 초과하면 서버를 통해 데이터를 다시 조회하고 캐시를 갱신한다. 이 때 다시 네트워크 다운로드가 발생하게 된다.&lt;/p&gt;

&lt;p&gt;사실 캐시 유효시간이 초과해서 클라이언트가 서버에 다시 해당 데이터를 요청하면 2가지 상황이 일어난다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;서버에서 기존 데이터를 변경했을 경우 : 서버에서 해당 데이터를 변경했을 경우 클라이언트는 서버 측에서 데이터를 다시 전달받아야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서버에서 기존 데이터를 변경하지 않았을 경우 : 캐시가 만료되었지만 서버에서 해당 데이터를 변경하지 않았을 경우에는 저장했던 캐시데이터를 다시 사용해도 상관이 없다.
단, 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법이 필요하다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2번의 경우에는 &lt;strong&gt;검증 헤더&lt;/strong&gt;를 사용하여 클라이언트의 데이터가 서버의 데이터와 일치하는지 여부를 확인이 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;검증-헤더&quot;&gt;검증 헤더&lt;/h2&gt;

&lt;p&gt;검증헤더를 사용했을 경우 클라이언트의 캐시데이터가 어떻게 처리되는지를 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-17-48-43.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 클라이언트가 star.jpg를 서버에 요청한다. 서버는 star.jpg를 클라이언트에 전달하면서 star.jpg의 &lt;strong&gt;최종수정일을 클라이언트에 보낸다.&lt;/strong&gt; 클라이언트는 받은 데이터를 브라우저 캐시저장소에 저장한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-17-49-40.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클라이언트의 캐시데이터 시간이 만료되어 서버에 다시 star.jpg를 요청한다. 요청할 때 HTTP 헤더에 if-modified-since를 보낸다. 클라이언트가 가지고 있는 star.jpg의 최종수정일이 서버의 최종수정일과 다른지를 확인하는 것이다.&lt;/p&gt;

&lt;p&gt;최종 수정일이 다르지 않다는 것을 확인한 서버는 HTTP헤더에 304 Not Modified라는 상태코드를 넣어서 보내게 된다. 수정되지 않았으므로 캐시데이터를 그대로 사용하라는 의미가 된다 &lt;strong&gt;이 때, 이미지는 보내지 않고 HTTP 헤더만 보내게 되므로 데이터 용량은 0.1MB가 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;클라이언트는 서버의 응답을 받고 캐시데이터를 갱신하여 캐시저장소에서 불러온 이미지를 다시 사용하여 홈페이지를 랜더링하게 된다.&lt;/p&gt;

&lt;p&gt;정리를 하자면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면&lt;/li&gt;
  &lt;li&gt;304 Not Modified + 헤더 메타정보만 응답데이터에 보낸다.&lt;/li&gt;
  &lt;li&gt;클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타정보를 갱신한다.&lt;/li&gt;
  &lt;li&gt;클라이언트는 캐시에 저장되어있는 데이터를 재활용한다.&lt;/li&gt;
  &lt;li&gt;결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드 한다.&lt;/li&gt;
  &lt;li&gt;실용적인 해결책이라 볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;검증-헤더와-조건부-요청&quot;&gt;검증 헤더와 조건부 요청&lt;/h2&gt;

&lt;h3 id=&quot;검증-헤더-1&quot;&gt;검증 헤더&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;검증 헤더는 캐시 데이터외 서버 데이터가 같은지 검증하는 데이터이다.&lt;/li&gt;
  &lt;li&gt;Last-Modified, ETag가 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;조건부-요청-헤더&quot;&gt;조건부 요청 헤더&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;검증 헤더로 조건에 따른 분기&lt;/li&gt;
  &lt;li&gt;If-Modified-Since: Last-Modified를 사용한다.&lt;/li&gt;
  &lt;li&gt;If-None-Match: ETag를 사용한다.&lt;/li&gt;
  &lt;li&gt;조건이 만족하게되면 200 OK로 응답한다.&lt;/li&gt;
  &lt;li&gt;조건이 만족하지 않으면 304 Not Modified로 응답한다. (실패했다는 것이 아니라 데이터가 수정된 것이 없으니 그대로 사용하라는 뜻이다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ETag가 존재하는 이유에 주목해야한다. 위에서 캐시데이터의 최종 수정일을 비교하여 변경된 사항이 없으면 캐시데이터를 그대로 사용하였다. 먼저 Last-Modified, If-Modified-Since의 단점에 대해서 알아보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1초 미만(0.x초) 단위로 캐시 조정이 불가능하다.&lt;/li&gt;
  &lt;li&gt;날짜 기반의 로직을 사용한다.&lt;/li&gt;
  &lt;li&gt;데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우
    &lt;ul&gt;
      &lt;li&gt;스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우, 이미 데이터가 약간이라도 변경되어 최종수정일이 갱신되어서 다시 데이터를 받아야한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 단점을 개선하기 위해서 ETag를 사용한다. ETag는 Entity Tag의 줄임말로, 캐시용 데이터에 임의의 고유한 버전 이름을 달아둔 것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ETag: “v1.0”, ETag: “a2jiodwjekjl3”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;데이터가 변경되면 ETag의 이름을 바꾸어서 변경한다(Hash를 다시 생성하는 것이다.)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ETag: “aaaaa” -&amp;gt; ETag: “bbbbb”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;캐시데이터를 갱신할 때는 단순하게 ETag만 비교하여 같으면 유지하고, 다르면 다시 받도록 처리한다. 아래 사진은 ETag로 캐시데이터를 갱신하는 것을 그림으로 표현한 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-21-39-23.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-21-39-48.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;etag-정리&quot;&gt;ETag 정리&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;단순히 ETag만 서버에 보내서 같으면 유지하고, 다르면 다시 받는다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;캐시 제어 로직을 서버에서 완전히 관리하게 된다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;클라이언트는 단순히 이 값을 서버에 제공한다(클라이언트는 캐시 매커니즘을 모른다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;캐시-제어-헤더&quot;&gt;캐시 제어 헤더&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Cache-Control: 캐시를 제어
    &lt;ul&gt;
      &lt;li&gt;Cache-Control: max-age
        &lt;ul&gt;
          &lt;li&gt;캐시의 유효시간, &lt;strong&gt;초 단위&lt;/strong&gt; 기준이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Cache-Control: no-cache
        &lt;ul&gt;
          &lt;li&gt;데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용하도록 설정&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Cache-Control: no-store
        &lt;ul&gt;
          &lt;li&gt;데이터에 민감한 정보가 있어서 캐시로 저장하면 안되는 데이터(메모리에서 사용 후 최대한 빨리 삭제한다.)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pragma : 케시를 제어(Cache-Control 하위호환)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Cache-Control과 역할은 같다. 주로 HTTP 1.0에 호환하기 위해서 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Expires : 캐시 만료일을 지정(Cache-Control: max-age 하위호환)
    &lt;ul&gt;
      &lt;li&gt;캐시 만료일을 정확한 &lt;strong&gt;날짜로 지정&lt;/strong&gt;한다.&lt;/li&gt;
      &lt;li&gt;HTTP 1.0부터 사용할 수 있다.&lt;/li&gt;
      &lt;li&gt;지금은 더 유연하게 적용이 가능한 Cache-Control: max-age를 권장한다.&lt;/li&gt;
      &lt;li&gt;Cache-Control: max-age와 함께 사용 시 Expires는 무시된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;검증-헤더와-조건부-요청-헤더&quot;&gt;검증 헤더와 조건부 요청 헤더&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;검증 헤더(Validator)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;ETag: “v1.0”, ETag: “asid93jkrh2l”&lt;/li&gt;
      &lt;li&gt;Last-Modified: Thu, 04 Jun 2020 07:19:24 GMT&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;조건부 요청 헤더&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;If-Match, If-None-Match: ETag 값 사용&lt;/li&gt;
      &lt;li&gt;If-Modified-Since, If-Unmodified-Since: Last-Modified값 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프록시-캐시&quot;&gt;프록시 캐시&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-21-54-35.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클라이언트가 미국에 있는 원 서버에 접근하기 까지 0.5초의 시간이 걸린다. 0.5초는 짧은 시간이지만 웹페이지를 이동할 때마다 0.5초를 기다리는 것은 사용자입장에서 좋은 경험이 아니다.&lt;/p&gt;

&lt;p&gt;따라서 프록시 캐시 서버를 만들어서 미국에서 먼 사용자들이 프록시 캐시서버를 사용하여 웹페이지와 통신할 수 있도록 설계하면 이를 개선시킬 수 있다. CDN같은 서비스가 이에 해당한다.&lt;/p&gt;

&lt;p&gt;유튜브를 예로 들자면, 영상을 맨 처음 보는 유저는 캐시를 다운로드받아야해서 로딩 속도가 느려진다. 하지만 다른사람들은 처음 본 유저 덕분에 캐시가 다운로드되어 영상을 빠른속도로 볼 수 있게 된다.&lt;/p&gt;

&lt;p&gt;중간에서 공용으로 사용하는 프록시 캐시서버를 public 캐시라 하고, 웹 브라우저에서 사용하는 캐시를 private 캐시라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cache-control-캐시-지시어기타&quot;&gt;Cache-Control: 캐시 지시어(기타)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Cache-Control: public - 응답이 public 캐시에 저장되어도 된다는 뜻이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cache-Control: private - 응답이 해당 사용자만을 위한 것이다. private 캐시에 저장되어야한다.(기본값)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;캐시-무효화&quot;&gt;캐시 무효화&lt;/h2&gt;

&lt;h3 id=&quot;cache-control-확실한-캐시-무효화-응답&quot;&gt;Cache-Control: 확실한 캐시 무효화 응답&lt;/h3&gt;

&lt;p&gt;캐시가 되어선 안되는 데이터는 캐시가 되지 않도록 설정해주어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cache-Control: no-cache, no-store, must-revalidate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-21-58-41.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;no-cache: 데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;no-cache를 한다고 가정해보자, 원 서버에 검증하고 사용해야되므로, 프록시서버에서 no-cache를 확인하면 원서버로 캐시데이터를 보낸다.&lt;/p&gt;

&lt;p&gt;하지만 원서버가 순간적으로 접속이 끊겨서 원서버에서 검증을 실패했다고 가정해보자, 이럴 경우 &lt;strong&gt;프록시 서버에서는 이전 데이터를 클라이언트 측으로 보낸다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;에를들어 통장 잔고나 민감한 개인정보의 경우는 이전 데이터를 클라이언트로 보내서는 안된다. 자칫 사용자에게 정보에 대한 혼동을 줄 수 있게된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-02-22-00-25.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;must-revalidate: 캐시 만료 후 최초 조회 시 원 서버에 검증을 해야한다.
원 서버에 접근 실패 시 반드시 오류가 발생해야한다. - 504(Gateway Timeout)
must-revalidate는 캐시 유효시간이라면 캐시를 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;must-revalidate는 캐시 만료 후 최초 조회 시 원 서버에 검증해야하는 것은 no-cache와 같은 공통점을 가진다. 하지만 원 서버에 접근 실패 시 반드시 오류가 발생해야하는 조건을 가지고 있다. 따라서 반드시 원 서버에서 검증 후에 데이터를 사용해야할 경우 must-revalidate를 넣어주어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;no-store: 데이터에 민감한 정보가 있으므로 저장하면 안된다(메모리에서 사용 후 최대한 빨리 삭제)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pragma: no-cache&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;HTTP 1.0 하위호환&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Achasan</name>
        
        
      </author>

      

      
        <category term="SpringBoot" />
      

      
        <summary type="html">HTTP 웹 기본 지식 8</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">HTTP API 설계방법(REST API)</title>
      <link href="https://achasan.github.io/http_basic_4" rel="alternate" type="text/html" title="HTTP API 설계방법(REST API)" />
      <published>2021-11-01T00:00:00+09:00</published>
      <updated>2021-11-01T00:00:00+09:00</updated>
      <id>https://achasan.github.io/http_basic_4</id>
      <content type="html" xml:base="https://achasan.github.io/http_basic_4">&lt;h1 id=&quot;http-웹-기본-지식-4&quot;&gt;HTTP 웹 기본 지식 4&lt;/h1&gt;

&lt;h2 id=&quot;http-api-설계&quot;&gt;HTTP API 설계&lt;/h2&gt;

&lt;p&gt;HTTP API를 설계한다고 가정해보자, 회원목록 조회, 회원 조회, 회원 등록, 회원 수정, 회원 삭제를 구현한다고 했을 때,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;회원 목록 조회 /read-member-list&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;회원 조회 /read-member-by-id&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;회원 등록 /create-member&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;회원 수정 /update-member&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;회원 삭제 /delete-member&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 URI를 좋은 설계라고 말할 수 있을 까? HTTP API 설계 시 가장 중요한 점은 리소스를 식별할 수 있어야 한다는 점이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;회원을 등록하고 수정하고 조회하는 것이 리소스가 아니다. 회원이라는 개념 자체가 리소스이다. 주어에 포커스를 두어야 한다. 회원이라는 리소스만 식별하여 회원 리소스를 URI에 매핑하는 것이 올바른 HTTP API의 설계이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;URI는 리소스만 식별하도록 하게한다. 리소스와 해당 리소스를 대상으로하는 행위를 분리해야한다. 주어와 동사를 분리해서 설계해야한다는 것이다.&lt;/p&gt;

&lt;p&gt;그렇다면 이제 정리해보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;리소스 : 회원&lt;/li&gt;
  &lt;li&gt;행위 : 조회, 등록, 삭제 변경(동사)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리소스는 명사, 행위는 동사가 된다. 그렇다면 이제 배운 내용을 바탕으로 URI 설계를 다시해보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;회원 목록 조회 /members&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;회원 조회 /members/{id}&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;회원 등록 /members/{id}&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;회원 수정 /members/{id}&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;회원 삭제 /members/{id}&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(계층 구조 상 상위를 컬렉션으로 보고 복수단어 사용을 권장한다.)&lt;/p&gt;

&lt;p&gt;일단 배운내용대로 리소스(회원)를 중심으로 URI를 설계하였다. 그렇다면 조회, 등록, 수정, 삭제를 어떤 방법으로 구분할 지가 궁금해질 것이다. &lt;strong&gt;HTTP 메서드&lt;/strong&gt;를 통해 이를 구분하는 것이 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;http-메서드의-종류&quot;&gt;HTTP 메서드의 종류&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;GET : 리소스 조회&lt;/li&gt;
  &lt;li&gt;POST : 요청 데이터를 처리, 주로 등록에 사용&lt;/li&gt;
  &lt;li&gt;PUT : 리소스를 대체한다, 해당 리소스가 없으면 생성한다.&lt;/li&gt;
  &lt;li&gt;PATCH : 리소스를 부분적으로 변경한다.&lt;/li&gt;
  &lt;li&gt;DELETE : 리소스를 삭제한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기타-메서드--head-options-connect-trace-가-있다-사용빈도-낮음&quot;&gt;기타 메서드 : HEAD, OPTIONS, CONNECT, TRACE 가 있다. (사용빈도 낮음)&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;get&quot;&gt;GET&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;리소스를 조회하는 메서드&lt;/li&gt;
  &lt;li&gt;서버에 전달하고 싶은 데이터는 &lt;strong&gt;query(쿼리파라미터, 쿼리스트링)&lt;/strong&gt;를 통해서 전달한다.&lt;/li&gt;
  &lt;li&gt;메시지 바디를 사용해서 데이터를 전달할 수 있지만 지원하는 곳이 적다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;post&quot;&gt;POST&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;요청 데이터를 처리한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메시지 바디를 통해&lt;/strong&gt; 서버로 요청 데이터를 전달한다.&lt;/li&gt;
  &lt;li&gt;서버는 요청 데이터를 처리하고, 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다.&lt;/li&gt;
  &lt;li&gt;서버는 주로 전달된 데이터를 통해 &lt;strong&gt;신규 리소스를 등록&lt;/strong&gt;하고, 프로세스 처리에 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리소스 URI에 POST 요청에 오면 요청 데이터를 어떻게 처리할 지 리소스마다 따로 정해야한다. (POST는 따로 정해진게 없다는 뜻이다.)&lt;/p&gt;

&lt;p&gt;POST는 회원가입, 주문하기, 게시판 글쓰기, 댓글달기, 신규 주문 생성, 기존 자원에 데이터 추가와 같이 새로운 리소스를 생성하거나 입력 폼을 통해 데이터를 전달하여 서버에서 처리할 수 있는 작업을 할 때 사용되는 메서드이다. 다른 메서드를 사용하기 애매할 경우에는 POST를 사용할 정도로 거의 모든 데이터처리를 할 때 사용될 수 있는 메서드이다.&lt;/p&gt;

&lt;p&gt;[정리]&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;새 리소스 생성(등록)
    &lt;ul&gt;
      &lt;li&gt;서버가 아직 식별하지 않은 새 리소스를 생성해준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;요청 데이터를 처리
    &lt;ul&gt;
      &lt;li&gt;단순히 데이터를 생성하거나, 변경하는 것을 넘어 프로세스를 처리해야하는 경우에 해당한다.&lt;/li&gt;
      &lt;li&gt;주문의 경우 결제완료 &amp;gt; 배달 시작 &amp;gt; 배달완료처럼 단순히 값 변경을 넘어 프로세스의 상태가 변경되는 경우에도 POST를 사용한다.&lt;/li&gt;
      &lt;li&gt;POST의 결과로 새로운 리소스가 생성되지 않을 수도 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다른 메서드로 처리하기 애매한 경우 POST를 사용한다.
    &lt;ul&gt;
      &lt;li&gt;ex. JSON으로 조회 데이터를 넘겨야하는데 GET메서드를 사용하기 어려운 경우
사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;put&quot;&gt;PUT&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;리소스를 완전히 대체한다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;리소스가 있으면 대체한다.&lt;/li&gt;
      &lt;li&gt;리소스가 없으면 생성한다.&lt;/li&gt;
      &lt;li&gt;리소스를 덮어씌운다고 생각하면 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;클라이언트가 리소스를 식별한다&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;클라이언트가 리소스 위치를 알고 URI를 지정한다.&lt;/li&gt;
      &lt;li&gt;POST와의 차이점이다. POST는 서버에서 리소스를 지정하지만 PUT은 클라이언트에서 지정한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 리소스를 완전히 대체한다는 점에 주목해야한다. 예를 들어서 ID가100인 회원의 나이를 수정하기위해 “AGE” : 20을 PUT 메서드로 보낸다고 했을 때 서버에서는 ID 100에 “NAME” : STEVE, “AGE” : 50 이 저장되어있다면 서버의 데이터는 “AGE” : 20으로 완전히 대체된다. 이름이 누락되어버리는 것이다. 따라서 PUT을 사용할 경우 신중하게 입력 폼을 작성하는 것이 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;patch&quot;&gt;PATCH&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;리소스를 부분변경한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PUT이 데이터를 완전 대체한다고 하면 PATCH는 부분변경이다. 위의 예시를 다시 참조하면, “AGE” : 20을 서버에 보내면 서버의 데이터는 “NAME” : STEVE, “AGE” : 20이 된다. NAME 데이터가 유지된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;delete&quot;&gt;DELETE&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;리소스를 삭제한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;http-메서드의-속성&quot;&gt;HTTP 메서드의 속성&lt;/h2&gt;

&lt;p&gt;HTTP 메서드를 보기 전에 유의해야할 점 : &lt;strong&gt;해당 리소스만 고려&lt;/strong&gt;한다. 외부적인 요인은 고려하지 않는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;안전(Safe Methods) : 호출해도 리소스가 변경되지 않음(GET, HEAD)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;멱등(Idempotent Methods)&lt;/strong&gt; : 한 번 호출하든 두 번 호출하든 100번 호출하든 결과가 같다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;GET : 한 번 조회하든 두 번 조회하든 같은 결과가 조회된다.&lt;/li&gt;
      &lt;li&gt;PUT : 결과를 대체한다. 따라서 같은 요청을 여러 번 해도 대체된 결과를 출력하기 때문에 최종적인 결과는 같다.(리소스 자체만 따져봐야한다. 대체되는 과정은 포함하지 않음.)&lt;/li&gt;
      &lt;li&gt;DELETE : 결과를 삭제하면 그 리소스는 지워진다. 삭제된 결과는 같다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;POST&lt;/strong&gt; : 두 번 호출하면 같은 결제가 중복해서 발생할 수 있다. 멱등에 해당되는 부분&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;캐시가능(Cacheable Methods) : 응답결과 리소스를 캐시해서 사용해도 되는지의 여부&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;GET, HEAD, POST, PATCH는 캐시가 가능하다.
        &lt;ul&gt;
          &lt;li&gt;실제로는 GET, HEAD 정도만 캐시로 사용한다. POST, PATCH는 본문 내용까지 캐시 키로 고려해야한다. 하지만 구현이 쉽지 않다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;http-메서드-활용&quot;&gt;HTTP 메서드 활용&lt;/h2&gt;

&lt;p&gt;이제 HTTP 메서드를 활용해보도록 하자. 클라이언트에서 서버로 데이터를 전송해야하는 상황에서 HTTP API를 설계하는 예시를 들어볼 것이다.&lt;/p&gt;

&lt;h3 id=&quot;클라이언트에서-서버로-데이터를-전송하는-방식&quot;&gt;클라이언트에서 서버로 데이터를 전송하는 방식&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;쿼리 파라미터를 통한 데이터 전송(GET) : 주로 정렬 필터에 사용한다.(검색어)&lt;/li&gt;
  &lt;li&gt;메시지 바디를 통한 데이터 전송(POST, PUT, PATCH) : 회원가입, 상품주문, 리소스 등록, 리소스 변경에 주로 사용되어진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;데이터를 전송하는 상황은 4가지의 상황으로 구분한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;정적 데이터 조회&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;이미지, 정적 테스트 문서&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;동적 데이터 조회&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;주로 검색, 게시판 목록에서 정렬 필터(검색어)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTML form을 통한 데이터 전송&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;회원가입, 상품주문, 데이터 변경&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP API를 통한 데이터 전송&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;회원가입, 상품주문, 데이터 변경&lt;/li&gt;
      &lt;li&gt;서버 to 서버, 앱 클라이언트, 웹 클라이언트(AJAX)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-01-20-15-54.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;정적-데이터-조회&quot;&gt;정적 데이터 조회&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;이미지나 정적 텍스트 문서를 조회&lt;/li&gt;
  &lt;li&gt;조회는 GET 방식을 사용한다.&lt;/li&gt;
  &lt;li&gt;정적 데이터는 일반적으로 &lt;strong&gt;쿼리 파라미터 없이 리소스 경로로 단순하게 조회&lt;/strong&gt;가 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-01-20-16-37.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;동적-데이터-조회&quot;&gt;동적 데이터 조회&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;쿼리 파라미터를 사용&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;/search?q=hello&amp;amp;hl=ko&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;uri뒤에 있는 쿼리파라미터를 통해서 쿼리 파라미터에 따른 응답 결과를 다르게 출력하는 동적인데이터를 조회한다.&lt;/li&gt;
      &lt;li&gt;조회 조건을 줄여주는 필터, 조회 결과를 정렬하는 정렬 조건에 주로 사용한다. 조회는 GET방식을 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-01-20-18-26.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;html-form-데이터-전송--post-방식&quot;&gt;HTML Form 데이터 전송 : POST 방식&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;POST 방식은 URI에 쿼리파라미터가 존재하지 않는다. 대신 form 태그에 입력한 내용을 key와 value의 형태로 요청메시지의 &lt;strong&gt;메시지바디 부분에 담아서&lt;/strong&gt; 보내게 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Content-type : application/x-www-form-urlencoded
    &lt;ul&gt;
      &lt;li&gt;POST 방식으로 데이터를 전송할 경우 요청 HTTP 메시지의 Content type은 application/x-www-form-urlencoded로 설정되어 보내진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GET은 조회에서만 사용한다. 만약 form 태그로 입력한 데이터를 GET을 통해서 보내면 쿼리파라미터를 통해 보내게 된다. 좋지않다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-01-20-22-11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;enctype=”multipart/form-data” : 여러 Content-type의 데이터를 보낼 수 있게 해주는 인코딩 타입이다. form 태그에서 enctype 속성에 “multipart/form-data”를 입력하면 요청 메시지가 위의 사진처럼 입력되는데, 주로 바이너리 데이터를 전송할 때 사용된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;http-api-데이터-전송&quot;&gt;HTTP API 데이터 전송&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;아이폰은 클라이언트에서 서버로 바로 전송을 해야한다. 이럴 때 HTTP API 데이터를 사용한다.&lt;/li&gt;
  &lt;li&gt;서버 to 서버 : 백엔드 시스템 통신이다.&lt;/li&gt;
  &lt;li&gt;앱 클라이언트 : 아이폰, 안드로이드에서만 사용한다.&lt;/li&gt;
  &lt;li&gt;웹 클라이언트 : HTML에서 Form 전송 대신 자바 스크립트를 통한 통신에 사용한다(AJAX) &amp;gt; React, Vue.js와 같은 웹 클라이언트와 통신&lt;/li&gt;
  &lt;li&gt;POST, PUT, PATCH : 메시지 바디를 통해 데이터를 전송한다.&lt;/li&gt;
  &lt;li&gt;GET : 조회, 쿼리파라미터로 데이터를 전달한다.&lt;/li&gt;
  &lt;li&gt;Content-Type: application/json을 주로 사용한다(사실 상 표준) &amp;gt; TEXT, XML, JSON 등등&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;http-설계-예시-컬렉션-스토어-컨트롤-uri&quot;&gt;HTTP 설계 예시 (컬렉션, 스토어, 컨트롤 URI)&lt;/h1&gt;

&lt;p&gt;HTTP API를 설계하는 예시를 통해 HTTP 데이터 전송 시 사용되는 개념들을 익혀본다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;회원관리-시스템--post&quot;&gt;회원관리 시스템 : POST&lt;/h2&gt;

&lt;p&gt;다시 회원 리소스로 돌아가보자, 배운 내용을 바탕으로 이제 회원 리소스로 CRUD를 어떻게 설계해야되는지 알았다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;회원 목록 /members : GET&lt;/li&gt;
  &lt;li&gt;회원 등록 /members : POST&lt;/li&gt;
  &lt;li&gt;회원 조회 /members/{id} : GET&lt;/li&gt;
  &lt;li&gt;회원 수정 /members/{id} : PATCH, PUT, POST&lt;/li&gt;
  &lt;li&gt;회원 삭제 /members/{id} : DELETE&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우리가 봐야할 건 회원 등록이 POST 기반으로 등록된다는 점이다. POST는 신규 자원을 등록할 때 사용할 수 있는데, 몇 가지 특징을 가지고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;클라이언트는 등록될 리소스의 URI를 모른다.&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;회원 등록 /members : POST&lt;/li&gt;
      &lt;li&gt;POST /members&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;서버가 새로 등록된 리소스 URI를 생성&lt;/strong&gt;해준다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;HTTP/1.1 201 Created&lt;/li&gt;
      &lt;li&gt;Location : /members/100&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이 개념을 &lt;strong&gt;컬렉션(Collections)&lt;/strong&gt;이라고 한다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;서버가 관리하는 리소스 디렉토리&lt;/li&gt;
      &lt;li&gt;서버가 리소스의 URI를 생성하고 관리&lt;/li&gt;
      &lt;li&gt;여기서 컬렉션은 /members가 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;클라이언트는 그냥 /members URI로 등록할 데이터를 전송하고, 서버가 생성된 회원의 URI를 /members/100과 같이설정한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;파일관리-시스템--put&quot;&gt;파일관리 시스템 : PUT&lt;/h2&gt;

&lt;p&gt;이번에는 파일 관리 시스템을 구현한다고 가정해보자, 파일 목록, 파일 조회, 등록, 삭제, 대량 등록을 구현한다고 했을 때,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일 목록 /files -&amp;gt; GET&lt;/li&gt;
  &lt;li&gt;파일 조회 /files/{filename} -&amp;gt; GET&lt;/li&gt;
  &lt;li&gt;파일 등록 /files/{filename} -&amp;gt; PUT&lt;/li&gt;
  &lt;li&gt;파일 삭제 /files/{filename} -&amp;gt; DELETE&lt;/li&gt;
  &lt;li&gt;파일 대량 등록 /files -&amp;gt; POST&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음과 같이 구현할 수 있다. 파일을 등록할 때 PUT 방식을 사용하고, 대량 등록할 때 POST방식을 사용하는데, 어떤 특징이 있는 지 알아보자&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;put-신규자원-등록-특징&quot;&gt;PUT 신규자원 등록 특징&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;클라이언트가 리소스 URI를 알고있다.&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;파일 등록 /files/{filename} &amp;gt; PUT&lt;/li&gt;
      &lt;li&gt;PUT /files/star.jpg&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;클라이언트가 직접 리소스의 URI를 지정&lt;/strong&gt;한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이 개념을 &lt;strong&gt;스토어(Store)&lt;/strong&gt;라고 한다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;클라이언트가 관리하는 리소스 저장소이며&lt;/li&gt;
      &lt;li&gt;클라이언트가 리소스의 URI를 알고 관리한다.&lt;/li&gt;
      &lt;li&gt;스토어의 리소스는 /files&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;간단히 생각해보자, 파일을 업로드 할 때는 로컬파일의 위치가 클라이언트에 있으므로 클라이언트에서 업로드를 해야된다. 클라이언트에서 파일을 업로드 할 때 파일의 위치를 서버에서 미리 지정할 순 없다. 서버는 파일을 받은 다음 DB에 저장을 해야하기 때문에 주도권은 클라이언트에게 있다.&lt;/p&gt;

&lt;p&gt;따라서 클라이언트 리소스의 URI를 먼저 지정을 하고 서버에 전달하게된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;html-form-사용&quot;&gt;HTML FORM 사용&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;HTML FORM은 GET과 POST 방식만 지원한다.&lt;/li&gt;
  &lt;li&gt;AJAX 같은 기술을 사용해서 한계를 극복할 수 있다.&lt;/li&gt;
  &lt;li&gt;여기서는 순수 HTML FORM만 언급한다.&lt;/li&gt;
  &lt;li&gt;GET, POST 방식만 지원하므로 제약이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 회원목록을 HTML FORM 만 사용하여 개발한다고 가정해보자,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;회원 목록 /members -&amp;gt; GET&lt;/li&gt;
  &lt;li&gt;회원 등록 폼 /members/new -&amp;gt; GET&lt;/li&gt;
  &lt;li&gt;회원 등록 /members/new, /members -&amp;gt; POST&lt;/li&gt;
  &lt;li&gt;회원 조회 /members/{id} -&amp;gt; GET&lt;/li&gt;
  &lt;li&gt;회원 수정 폼 /members/{id}/edit -&amp;gt; GET&lt;/li&gt;
  &lt;li&gt;회원 수정 /members/{id}/edit, /members/{id} -&amp;gt; POST&lt;/li&gt;
  &lt;li&gt;회원 삭제 /members/{id}/delete -&amp;gt; POST&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;URI를 보면 GET과 POST로만 구현을 해야하기 때문에 어쩔 수 없이 리소스 외에 동사를 사용하여 URI를 설계한 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;이 개념을 &lt;strong&gt;컨트롤 URI&lt;/strong&gt;라고한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GET, POST만 지원하므로 제약이 있음&lt;/li&gt;
  &lt;li&gt;이런 제약을 해결하기위해 동사로 된 리소스 경로를 사용&lt;/li&gt;
  &lt;li&gt;POST의 /new, /edit, /delete가 컨트롤 URI&lt;/li&gt;
  &lt;li&gt;HTTP 메서드로 해결하기 애매한 경우에 사용된다.&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Achasan</name>
        
        
      </author>

      

      
        <category term="SpringBoot" />
      

      
        <summary type="html">HTTP 웹 기본 지식 4</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">HTTP 상태코드, PRG(Post Redirect Get)</title>
      <link href="https://achasan.github.io/http_basic_5" rel="alternate" type="text/html" title="HTTP 상태코드, PRG(Post Redirect Get)" />
      <published>2021-11-01T00:00:00+09:00</published>
      <updated>2021-11-01T00:00:00+09:00</updated>
      <id>https://achasan.github.io/http_basic_5</id>
      <content type="html" xml:base="https://achasan.github.io/http_basic_5">&lt;h1 id=&quot;http-웹-기본-지식-5&quot;&gt;HTTP 웹 기본 지식 5&lt;/h1&gt;

&lt;h2 id=&quot;http-상태-코드&quot;&gt;HTTP 상태 코드&lt;/h2&gt;

&lt;p&gt;HTTP 상태코드는 클라이언트가 보낸 요청의 처리 상태를 응답해서 알려주는 기능을 말한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1xx (Informational): 요청이 수신되어 처리중&lt;/li&gt;
  &lt;li&gt;2xx (Successful): 요청 정상 처리&lt;/li&gt;
  &lt;li&gt;3xx (Redirection): 요청을 완료하려면 추가 행동이 필요&lt;/li&gt;
  &lt;li&gt;4xx (Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음&lt;/li&gt;
  &lt;li&gt;5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만약 클라이언트가 인식할 수 없는 상태코드를 서버가 반환하더라도 클라이언트는 상위 상태코드로 해석하여 처리한다. 미래에 새로운 상태코드가 추가되더라도 클라이언트를 변경할 필요가 없어진다. 각 상태코드의 특징을 알아보자.&lt;/p&gt;

&lt;h3 id=&quot;1xx--거의-사용하지않으므로-생략&quot;&gt;1xx : 거의 사용하지않으므로 생략&lt;/h3&gt;

&lt;h2 id=&quot;2xx-successful&quot;&gt;2xx (Successful)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;200 OK : 서버가 클라이언트의 요청을 성공적으로 처리하면 200 상태코드를 전송한다. &lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-01-22-19-11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;201 Created : 클라이언트의 요청을 성공해서 새로운 리소스가 만들어 졌을 때 전송한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;202 Accepted : 요청이 접수되었으나 처리가 완료되지 않았을 경우&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;배치처리 같은 곳에서 사용한다.(요청 접수 후 1시간 뒤에 배치 프로세스가 처리)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;204 No Content : 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없을 때&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;게시글 내용을 자동저장하는 경우에 포함 : 자동저장 버튼을 누르더라도 서버에서 따로 보낼 메시지는 없어도 되며, 같은 하면을 유지해야함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3xx-redirection&quot;&gt;3xx (Redirection)&lt;/h2&gt;

&lt;p&gt;3xx는 요청을 완료하기 위해 유저 에이전트의 추가 조치가 필요할 경우 사용한다. 그 전에 먼저 리다이렉트가 어떤 건지 알아보자. 먼저 리다이렉트가 무엇인지 그림으로 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-01-22-23-43.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;클라이언트가 /event URI을 요청&lt;/li&gt;
  &lt;li&gt;서버에서는 301 상태코드와 Location 헤더를 전송, Location에는 /new-event URI가 담겨있음.&lt;/li&gt;
  &lt;li&gt;클라이언트는 자동으로 /new-event URI로 요청하게됨&lt;/li&gt;
  &lt;li&gt;서버에서는 URI에 맞는 비즈니스 로직을 처리하고 200 상태코드 전송&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;만약 3xx 응답의 결과에 Location 헤더가 있으면 Location 위치로 자동이동하는데, 이를 리다이렉트라고 한다. 리다이렉트는 여러 종류가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;영구 리다이렉션 (301, 308)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;리소스의 URI가 영구적으로 이동하게됨&lt;/li&gt;
      &lt;li&gt;원래의 URL을 사용하지 않고, 검색엔진 등에서도 변경을 인지&lt;/li&gt;
      &lt;li&gt;301 : Moved Permanently
        &lt;ul&gt;
          &lt;li&gt;리다이렉트 시 &lt;strong&gt;요청 메서드가 GET으로 변하고&lt;/strong&gt;, 본문이 제거될 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-01-22-29-13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;308 : Permanent Redirect
        &lt;ul&gt;
          &lt;li&gt;301과 기능은 같다. 리다이렉트시 &lt;strong&gt;요청 메서드와 본문을 유지&lt;/strong&gt;한다.(처음 POST를 보내면 리다이렉트도 POST방식을 유지한다.)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;일시적 리다이렉션(302, 307, 303)
    &lt;ul&gt;
      &lt;li&gt;리소스의 URI가 &lt;strong&gt;일시적으로 변경&lt;/strong&gt;된다.&lt;/li&gt;
      &lt;li&gt;검색엔진에서 URI를 변경하면 안된다.&lt;/li&gt;
      &lt;li&gt;302 Found
        &lt;ul&gt;
          &lt;li&gt;리다이렉트시 &lt;strong&gt;요청 메서드가 GET으로 변하고&lt;/strong&gt;, 본문이 제거될 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;307 Temporary Redirect
        &lt;ul&gt;
          &lt;li&gt;302와 기능은 같다, 리다이렉트시 &lt;strong&gt;요청 메서드와 본문을 유지&lt;/strong&gt;한다.(요청 메서드를 변경하면 안된다.)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;303 See Other
        &lt;ul&gt;
          &lt;li&gt;302와 기능은 같다. 리다이렉트시 &lt;strong&gt;요청 메서드가 GET으로 변경&lt;/strong&gt;된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;prg-post-redirect-get&quot;&gt;PRG: Post Redirect Get&lt;/h3&gt;

&lt;p&gt;일시적인 리다이렉션의 예시를 알아보자. POST방식으로 주문 후에 웹 브라우저를 새로고침하면 어떻게 될까? 새로고침은 주문을 다시 요청하기 때문에 중복 주문이 되어 문제가 생길 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-01-22-33-59.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;결과화면에서 새로고침을 하면 이전에 했던 요청을 다시하게되고, 서버는 DB에 해당 주문내역을 저장하게된다. 이럴 경우 중복 주문이 되어 클레임이 들어올 수 있고, 큰 문제가 될 수 있다. 이를 방지하기위해서 PRG를 사용한다. PRG를 사용하면 위의 중복주문을 방지할 수 있는데,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;POST로 주문 후 새로고침으로 인한 중복 주문을 방지&lt;/li&gt;
  &lt;li&gt;POST로 주문 후에 주문 결과 화면을 GET메서드로 리다이렉트&lt;/li&gt;
  &lt;li&gt;GET 메서드는 조회만 가능하도록 설계되므로 새로고침해도 결과화면이 조회만 된다.&lt;/li&gt;
  &lt;li&gt;중복 주문 대신 결과화면만 GET으로 다시 요청&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-01-22-36-06.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PRG를 사용했을 경우의 과정이다. POST 방식이 GET 방식으로 변경되어 새로고침을 하더라도 주문 요청이 아닌 조회가 요청되어 응답으로 주문완료 데이터가 전송되는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;일시적인 리다이렉션은 302, 307, 303 세 가지가 있다. 어떤 것을 써야될까? 각 특징을 살펴보면&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;302 Found -&amp;gt; GET으로 변할 수 있음&lt;/li&gt;
  &lt;li&gt;307 Temporary Redirect -&amp;gt; 메서드가 변하면 안됨&lt;/li&gt;
  &lt;li&gt;303 See Other -&amp;gt; 메서드가 GET으로 변경&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;원래 302의 의도는 HTTP 메서드를 유지하는 것이었다. 하지만 명확하게 명시가 되어있지 않아 웹 브라우저에서는 대부분 GET 방식으로 바꿔서 사용을 했다. 이를 명확히 하기위해 나중에 307, 303이 등장하게 되었다.&lt;/p&gt;

&lt;p&gt;하지만 현실적으로 이미 많은 애플리케이션 라이브러리들이 302를 기본값으로 사용하기 때문에 GET으로 변해도 된다면 302를 사용해도 큰 문제는 없다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;기타-리다이렉션&quot;&gt;기타 리다이렉션&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;304 : Not Modified
    &lt;ul&gt;
      &lt;li&gt;캐시를 목적으로 사용하는 리다이렉션&lt;/li&gt;
      &lt;li&gt;클라이언트에게 리소스가 수정되지 않았음을 알려주는 상태코드이다. 이를 통해 클라이언트는 로컬 PC에서 저장된 캐시를 재사용할 수 있게 된다. (가지고 있는 캐시 데이터가 서버에서 수정되었는지, 만료되었는지를 확인하기위해 사용)&lt;/li&gt;
      &lt;li&gt;304 응답은 응답에 메시지 바디를 포함해서는 안된다.(로컬 캐시를 사용해야하기 때문)&lt;/li&gt;
      &lt;li&gt;조건부 GET, HEAD 요청시에 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4xx-클라이언트-오류&quot;&gt;4xx 클라이언트 오류&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;클라이언트의 요청에 잘못된 문법 등으로 서버가 요청을 수행하지 못함&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;오류의 원인이 클라이언트에 있음&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;클라이언트가 이미 잘못된 요청, 데이터를 보내기 때문에 똑같은 재시도가 실패한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4xx-상태코드의-종류&quot;&gt;4xx 상태코드의 종류&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;400 Bad Request : 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없다. 클라이언트는 요청 내용을 다시 검토하고 보내야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;401 Unauthorized : 클라이언트가 해당 리소스에 대한 인증이 필요할 때
    &lt;ul&gt;
      &lt;li&gt;인증되지가 않았을 때 보내는 상태코드&lt;/li&gt;
      &lt;li&gt;응답에 WWW-Authenticate 헤더와 함께 인증방법을 설명한다.&lt;/li&gt;
      &lt;li&gt;참고 : 인증(Authentication) = 본인이 누구인지 확인(로그인), 인가(Authorization) = 권한부여(특정 리소스에 접근할 수 있는 권한, 인증이 있어야 인가가 있다.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;403 Forbidden : 서버가 요청을 이해했지만 승인을 거부하는 경우
    &lt;ul&gt;
      &lt;li&gt;인증 자격 증명은 있지만 접근권한이 불충분한 경우에 보내는 상태코드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;404 Not Found : 요청 리소스를 찾을 수 없을 경우.
    &lt;ul&gt;
      &lt;li&gt;말 그대로 리소스가 서버에 없다. 또는 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶을 때 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;5xx-서버-오류&quot;&gt;5xx 서버 오류&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;서버 문제로 오류가 발생&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;서버에 문제가 있기 때문에 재시도하면 성공할 수도 있음&lt;/strong&gt;(복구가 됐을 때 등)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5xx-상태코드의-종류&quot;&gt;5xx 상태코드의 종류&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;500 Internal Server Error : 서버 문제로 오류가 발생하는 경우, 애매하면 500 오류가 발생하게끔 한다.&lt;/li&gt;
  &lt;li&gt;503 Service Unavailable : 서비스 이용 불가.
    &lt;ul&gt;
      &lt;li&gt;서버가 일시적인 과부하, 예정된 작업으로 잠시 요청을 처리할 수 있음&lt;/li&gt;
      &lt;li&gt;Retry-After 헤더 필드로 얼마 두에 복구되는지 보낼 수도 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;한 가지 알아야 할 점이라면 웬만해서는 서버 쪽 오류를 내지 않는 것이 좋다. 예를 들면 고객의 잔고가 부족할 때 서버 측 오류로 내면 안되고 클라이언트 오류로 내야한다. 고객의 잔고가 부족한 것이 서버에 문제가 있어서는 아니다.&lt;/p&gt;

&lt;p&gt;20살 이상만 주문을 해야하는데 18살이 주문을 했을 때도 서버 측 오류로 내면 안되고 클라이언트 오류로 내야한다.&lt;/p&gt;

&lt;p&gt;비즈니스 로직에 문제가 생겼을 때, DB서버에 문제가 생겼을 때 500 에러를 내야하지 &lt;strong&gt;예외케이스가 나왔다고 해서 서버 측 오류가 났다고 상태코드를 보내서는 안된다.&lt;/strong&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Achasan</name>
        
        
      </author>

      

      
        <category term="SpringBoot" />
      

      
        <summary type="html">HTTP 웹 기본 지식 5</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">HTTP의 개념(역사, 특징, Stateless, Stateful, 비연결성)</title>
      <link href="https://achasan.github.io/http_basic_3" rel="alternate" type="text/html" title="HTTP의 개념(역사, 특징, Stateless, Stateful, 비연결성)" />
      <published>2021-10-31T00:00:00+09:00</published>
      <updated>2021-10-31T00:00:00+09:00</updated>
      <id>https://achasan.github.io/http_basic_3</id>
      <content type="html" xml:base="https://achasan.github.io/http_basic_3">&lt;h1 id=&quot;http-웹-기본-지식-3&quot;&gt;HTTP 웹 기본 지식 3&lt;/h1&gt;

&lt;h2 id=&quot;http&quot;&gt;HTTP&lt;/h2&gt;

&lt;h3 id=&quot;http-메시지에-모든-것이-전송-가능&quot;&gt;HTTP 메시지에 모든 것이 전송 가능&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;HTML, TEXT&lt;/li&gt;
  &lt;li&gt;IMAGE, 음성, 영상 파일&lt;/li&gt;
  &lt;li&gt;JSON, XML(API)&lt;/li&gt;
  &lt;li&gt;거의 모든 형태의 데이터 전송이 가능&lt;/li&gt;
  &lt;li&gt;서버 간에 데이터를 주고 받을 떄도 대부분 HTTP를 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;http의-역사&quot;&gt;HTTP의 역사&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;1991년 : HTTP/0.9 - GET 메서드만 지원, HTTP 헤더 X&lt;/li&gt;
  &lt;li&gt;1996년 : HTTP/1.0 - 메서드와 헤더 추가됨&lt;/li&gt;
  &lt;li&gt;1997년 : HTTP/1.1 - 가장 많이 사용하고, 가장 중요한 버전이다.&lt;/li&gt;
  &lt;li&gt;2015년 : HTTP/2 - 성능 개선&lt;/li&gt;
  &lt;li&gt;현재진행중 : HTTP/3 - TCP 대신 UDP를 사용함, 성능 개선&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;가장 중요한 버전은 HTTP 1.1이다. 1.1 버전에서 대부분의 기능들을 가지고 있고, 이후의 버전들은 성능 개선에 초점을 맞추어서 업데이트되고 있다.&lt;/p&gt;

&lt;p&gt;현재 1.1 버전을 가장 많이 사용하고 있으며, 1.1 버전에 대한 개정은 2014년에 이루어진 RFC7235이다.&lt;/p&gt;

&lt;h3 id=&quot;http의-특징&quot;&gt;HTTP의 특징&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;클라이언트 서버 구조&lt;/li&gt;
  &lt;li&gt;무상태 프로토콜(Stateless), 비연결성&lt;/li&gt;
  &lt;li&gt;HTTP 메시지&lt;/li&gt;
  &lt;li&gt;단순함과 확장가능성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;무상태-프로토콜&quot;&gt;무상태 프로토콜&lt;/h2&gt;

&lt;h3 id=&quot;stateless&quot;&gt;Stateless&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;서버가 클라이언트의 상태를 보존하지 않는 것.&lt;/li&gt;
  &lt;li&gt;장점은 서버의 확정성이 높다.(스케일 아웃)&lt;/li&gt;
  &lt;li&gt;단점은 클라이언트가 추가 데이터를 전송한다는 점&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;stateful-stateless의-차이점&quot;&gt;Stateful, Stateless의 차이점&lt;/h3&gt;

&lt;p&gt;Stateful이 어떤 방식인지 다음 대화를 살펴보자&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;고객 : 이 노트북 얼마인가요?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;점원 : 100만원 입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;고객 : 2개 구매하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;점원 : 200만원입니다. 신용카드, 현금 중에 결제수단을 선택해주세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;고객 : 신용카드로 구매하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;점원 : 200만원 결제완료 되었습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;대화를 보면 처음부터 끝까지 내용이 이어지고 있다. 대화내용의 중간부분을 자르면 대화의 흐름을 이해할 수가 없을 것이다. 만약 점원이 중간에 바뀐다면 어떻게 될지 보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;고객: 이 노트북 얼마인가요?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;점원A: 100만원 입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;고객: 2개 구매하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;점원B: ? 무엇을 2개 구매하시겠어요?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;고객: 신용카드로 구매하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;점원C: ? 무슨 제품을 몇 개 신용카드로 구매하시겠어요?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Stateful은 상태가 유지되는 것으로, 고객이 노트북을 산다고 말하면서 노트북이 상태유지되고, 2개를 산다고 말하면서 상태유지가 되고, 신용카드로 결제한다고 이야기하면서 데이터의 전송이 마무리 된다. 데이터를 처리하기까지 서버와 클라이언트가 계속 연결이 유지되어있어야하고, 중간에 서버가 바뀌면 어떤 데이터가 유지되고 있었는지 알 수 없게된다.&lt;/p&gt;

&lt;p&gt;이제 Stateless를 알아보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;고객: 이 노트북 얼마인가요?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;점원A: 100만원 입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;고객: 노트북 2개 구매하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;점원B: 노트북 2개는 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매 하시겠어요?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;고객: 노트북 2개를 신용카드로 구매하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;점원C: 200만원 결제 완료되었습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;무상태는 고객이 구매하려는 모든 데이터 정보를 가지고 있어서 서버가 바뀌더라도 비즈니스 로직의 처리가 가능해진다. 모든 데이터를 담고 있어서 데이터가 무거워지는 단점을 가지고 있지만, 서버 입장에서는 서버 증설이 가능해지고, 갑자기 몰리는 트래픽을 방지할 수 있어서 더 선호되는 상태이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;stateful-stateless-정리&quot;&gt;Stateful, Stateless 정리&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Stateful(상태유지) : 중간에 다른 점원으로 바뀌면 안된다. (중간에 다른 점원으로 바뀔 때 상태 정보를 다른 점원에게 미리 알려줘야 한다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Stateless(무상태) : 중간에 다른 점원으로 바뀌어도 된다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;갑자기 고객이 증가해도 점원을 대거 투입할 수 있다.&lt;/li&gt;
      &lt;li&gt;갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Stateless는 응답서버를 쉽게 바꿀 수 있어서 무한한 서버 증설이 가능해진다.
이를 스케일 아웃(scale out)이라고 하는데, 무상태 요청정보를 클라이언트가 가지고 있어서 이를 읽을 수 있는 서버만 늘려주면 되기 때문에 대응하기가 훨씬 수월해진다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하지만 Stateless는 한계점을 가지고 있다. 대표적으로 로그인이다. 클라이언트에서 로그인을 했을 경우 서버에서는 로그인을 했다는 상태를 서버에 유지해야 다른 서비스들을 이용할 수 있다.&lt;/p&gt;

&lt;p&gt;일반적으로 브라우저 쿠키와 서버 세션등을 사용해서 상태를 유지한다. 상태유지는 최소한만 사용하는 것이 좋다.&lt;/p&gt;

&lt;p&gt;또한 Stateful에 비해서 Stateless는 데이터를 한 번에 많이 보낸다느 점도 단점이라할 수 있다.&lt;/p&gt;

&lt;p&gt;결론은 Stateless의 최대장점은 트래픽이 몰리더라도 서버를 왕창늘려도 비즈니스 로직을 처리하는데 문제가 없다는 것이다. 클라이언트 측에서 정보를 A부터 Z까지 가지고 있기 때문에 서버측에서 정보를 읽는데 문제가 없다. 이러한 메리트 때문에 Stateless로 설계하는 것이 좋다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;비연결성connectionless&quot;&gt;비연결성(Connectionless)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-10-31-22-58-37.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기본적으로 웹 애플리케이션이 가동되면 서버는 클라이언트와 연결을 유지한다. 클라이언트가 요청을 보내지 않더라도 서버는 요청이 올때까지 계속 연결을 유지시킨다. 연결이 계속 유지될수록 서버의 자원은 지속적으로 소모되어 좋지 않다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-10-31-22-59-19.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비연결성은 클라이언트와 서버 간에 쵸엉이 없을 경우에는 연결을 끊고 클라이언트의 요청이 들어오면 그때 다시 연결을 하는 것을 말한다. 이럴 경우에는 서버는 최소한의 자원으로 서버를 유지할 수 있게 된다.&lt;/p&gt;

&lt;p&gt;HTTP는 기본이 연결을 유지하지 않는 모델이다. 일반적으로 초 단위 이하의 빨느 속도로 응답하기 때문에 1시간동안 수 천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수 십개 이하로 매우 적다.(브라우저가 랜더링하면 정보를 얻어오는 시간이 있기 때문)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-10-31-23-03-07.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 비연결성의 단점은 무엇일까? 요청과 응답이 이루어지면 연결을 끊어버리기 때문에 다시 요청을 하기 위해선 새로 TCP/IP 연결을 맺어야한다는 점이다. 우리는 위에서 TCP/IP가 연결되는 과정을 보았다. 3 way handshake를 매 번 수행해야한다는 점은 별로 좋아보이지 않는다.&lt;/p&gt;

&lt;p&gt;또한 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 JS, CSS, 이미지 등 수 많은 자원들이 같이 다운로드가 된다. 하나 씩 받게되면서 연결과 종료를 반복하게 되는 것이다. 지금은 Persistent Connections(지속연결)을 통해 문제를 해결하였다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-10-31-23-03-28.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지속연결을 할 경우에는 HTML, JS, CSS 이미지들을 모두 다운받을 때 까지 연결을 지속한다. 모든 리소스들을 다 받은 다음에 연결이 종료되어 효율적인 서버자원활용을 가능하게 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;http-메시지&quot;&gt;HTTP 메시지&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-10-31-23-05-00.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이전 강의에서 HTTP를 요청하고 응답이 어떻게 이루어지는 지 전체적인 흐름을 살펴보았다. 이번에는 HTTP 메시지가 어떤 구조를 가지고 있는지를 알아본다.&lt;/p&gt;

&lt;p&gt;HTTP의 메시지 구조는&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;start-line(시작라인)&lt;/li&gt;
  &lt;li&gt;header(헤더)&lt;/li&gt;
  &lt;li&gt;empty line(공백라인) (CRLF : 엔터) : 꼭 있어야하는 라인&lt;/li&gt;
  &lt;li&gt;message body(바디태그) : 올 수도 있고 안 올수도 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;총 네 가지가 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;요청-메시지-구조&quot;&gt;요청 메시지 구조&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-10-31-23-44-16.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;start-line = request-line&lt;/li&gt;
  &lt;li&gt;request-line = method SP(공백) request-target SP HTTP-version CRLF(엔터)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하나 씩 천천히 살펴보자. 먼저 요청 메시지는 시작 라인이 요청라인으로, 요청 라인은&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;메서드 요청대상 HTTP버전&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;으로 이루어져 있다. 공백은 무조건 띄어쓰기를 해주어야한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP메서드&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;종류는 GET, POST, PUT, DELETE 등이 있다.&lt;/li&gt;
      &lt;li&gt;서버가 수행해야할 동작을 지정한다. (GET: 리소스 조회, POST: 요청 내역 처리)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;요청대상&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;구성은 absolute-path[?query]로 구성되어있다. (절대경로[?쿼리])&lt;/li&gt;
      &lt;li&gt;여기서 절대경로는 “/”로 시작하는 경로를 말한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP 버전 : 말 그대로 HTTP 버전을 나타낸다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;응답-메시지-구조&quot;&gt;응답 메시지 구조&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-01-17-45-07.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;start-line = status-line&lt;/li&gt;
  &lt;li&gt;status-line = HTTP-version SP status-code SP reason-phrase CRLF&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;응답 메시지는 총 3개로 이루어져 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;HTTP버전 HTTP상태코드 이유문구&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP 버전 : 말 그대로 HTTP 버전을 나타냄&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP 상태 코드 : 요청 성공, 실패를 나태낸다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;200 : 성공&lt;/li&gt;
      &lt;li&gt;400 : 클라이언트 요청 오류&lt;/li&gt;
      &lt;li&gt;500 : 서버 내부 오류&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이유 문구&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;사람이 이해할 수 있는 짧은 상태 코드를 설명하는 글&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;http-헤더&quot;&gt;HTTP 헤더&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-01-17-48-00.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;header-field = field-name “:” OWS field-value OWS (OWS : 띄어쓰기 허용)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;field-name은 대소문자 구분이 없다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;용도&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;HTTP 전송에 필요한 모든 부가정보를 담는다.(메시지 바디의 내용, 크기, 압축, 인증, 요청 클라이언트의 정보…)&lt;/li&gt;
      &lt;li&gt;표준 헤더가 너무 많다는 점이 특징&lt;/li&gt;
      &lt;li&gt;필요시에는 임의의 헤더가 추가 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;http-메시지-바디&quot;&gt;HTTP 메시지 바디&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-11-01-17-52-17.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실제로 전송할 데이터가 담겨있다.&lt;/li&gt;
  &lt;li&gt;HTML 문서, 이미지, 영상 JSON 등 byte로 표현할 수 있는 모든 데이터를 전송할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;http-정리&quot;&gt;HTTP 정리&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP 메시지에 모든 것을 전송할 수 있다.&lt;/li&gt;
  &lt;li&gt;HTTP버전은 1.1을 기준으로 한다. 이후 버전은 성능 개선에 초점이 맞춰져 있다.&lt;/li&gt;
  &lt;li&gt;클라이언트와 서버 구조는 요청과 응답을 통해 이루어진다.&lt;/li&gt;
  &lt;li&gt;무상태 프로토콜(Stateless)의 특징에 대해 알아두기&lt;/li&gt;
  &lt;li&gt;HTTP 메시지의 구조(요청, 응답)&lt;/li&gt;
  &lt;li&gt;HTTP는 단순하고 확장이 가능한 특징을 가지고 있다.&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Achasan</name>
        
        
      </author>

      

      
        <category term="SpringBoot" />
      

      
        <summary type="html">HTTP 웹 기본 지식 3</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">[Spring:9] 빈 스코프(Bean Scope)</title>
      <link href="https://achasan.github.io/spring_basic_9" rel="alternate" type="text/html" title="[Spring:9] 빈 스코프(Bean Scope)" />
      <published>2021-10-29T00:00:00+09:00</published>
      <updated>2021-10-29T00:00:00+09:00</updated>
      <id>https://achasan.github.io/spring_basic_9</id>
      <content type="html" xml:base="https://achasan.github.io/spring_basic_9">&lt;h1 id=&quot;빈-스코프-정리&quot;&gt;빈 스코프 정리&lt;/h1&gt;

&lt;h2 id=&quot;빈-스코프란&quot;&gt;빈 스코프란?&lt;/h2&gt;

&lt;p&gt;Bean Scope&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;SingleTon : 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ProtoType : 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프이다. 종료 메서드 호출이 되지 않는다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;웹 관련 스코프&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;request : 웹 요청이 들어오고 나갈 때 까지 유지되는 스코프&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;session : 웹 세션이 생성되고 종료될 때까지 유지되는 스코프&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;application : 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프로토타입-스코프&quot;&gt;프로토타입 스코프&lt;/h2&gt;

&lt;p&gt;프로토타입 스코프를 스프링 컨테이너에 조회하면 항상 새로운 인스턴스를 생성해서 반환한다(싱글턴이 아니다.)&lt;/p&gt;

&lt;p&gt;프로토타입 빈을 등록했을 경우, 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계를 주입하고, 초기화까지만 처리한다. 클라이언트에 빈을 반환하고 빈을 아예 관리하지 않는다. 따라서 클라이언트가 받은 프로토타입 빈을 관리할 책임을 갖는다. 초기화까지만 처리하기 때문에 @PreDestroy 종료 메서드는 호출되지 않는다.&lt;/p&gt;

&lt;p&gt;@Configuration 어노테이션을 주지 않더라도 AnnotationConfigApplicationContext 파라미터에 클래스를 넣어주면 해당 클래스는 컨테이너에 등록이 된다.(정확히 말하면 컴포넌트 스캔 목록에 해당되게된다.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;일반-스코프와-프로토타입-스코프의-차이점&quot;&gt;일반 스코프와 프로토타입 스코프의 차이점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;일반 스코프라면 (Singleton) 스프링 컨테이너가 등록될 때 빈이 생성되면서 init() 메서드가 실행되게 된다.(@PostConstruct)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로토타입 스코프는 스프링 컨테이너가 등록되면서 객체가 생성되지 않는다. 당연히 init() 메서드도 실행되지 않는다. 클라이언트가 프로토타입의 빈을 요청하면 그때 객체를 새로 생성하고 init() 메서드까지 한 다음에 클라이언트한테 객체를 던져주고 끝난다. 또한 같은 객체가 아닌 클라이언트가 요청할 때마다 새로운 객체를 생성해서 클라이언트한테 던져준다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;클라이언트에게 객체를 줘버리기 때문에 컨테이너가 죽을 때destroy() 메서드는 실행되지 않는다. 만약 destroy()를 호출할 필요가 있을 경우 코드를 통해 수정으로 호출해주어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프로토타입-스코프를-싱글톤-빈과-함께-사용시-문제점&quot;&gt;프로토타입 스코프를 싱글톤 빈과 함께 사용시 문제점&lt;/h2&gt;

&lt;p&gt;만약 싱글턴 빈에 프로토타입 빈을 의존관계 주입하게 되면 어떻게 될까? 싱글턴 빈은 컨테이너가 생성될 때 최초로 의존관계 주입이 되기 때문에 컨테이너에서 프로토타입 객체를 하나 생성해서 싱글턴 빈에 넣어줄 것이다.&lt;/p&gt;

&lt;p&gt;하지만 이렇게 된 다음 클라이언트가 싱글턴 빈을 호출하면 싱글턴 빈 안에 존재하는 프로토타입 빈만 계속 호출이 된다. 프로토타입 빈이 싱글턴이 되어버린 것이다.&lt;/p&gt;

&lt;p&gt;우리는 분명 싱글턴 빈에 프로토타입 빈을 의존관계 주입해서 빈을 호출할 때마다 새로운 프로토타입 빈 객체를 호출하게 구현하기를 원한다. 다른 방법을 찾아보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;싱글톤-빈과-함께-사용시-provider로-문제-해결&quot;&gt;싱글톤 빈과 함께 사용시 Provider로 문제 해결&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nd&quot;&gt;@Scope&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;singleton&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ClientBean&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;applicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;logic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;applicationContext&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;AnnotationConfigApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;PrototypeBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;PrototypeBean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prototypeBean&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;applicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;PrototypeBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;prototypeBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prototypeBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이전 강의에서 싱글턴 빈에 프토토타입 빈을 의존관계 주입했을 때 프로토 타입 빈이 싱글턴이 되어버리는 현상을 보았었다. 따라서 위의 코드 처럼 클라이언트가 logic() 메서드를 실행하면 ApplicationContext를 통해 컨테이너에 등록되어있는 프로토타입 빈을 가져오게하도록 코드를 작성하여 메서드를 호출할 때마다 새로운 빈을 생성하도록 (어거지로) 구현했다.&lt;/p&gt;

&lt;p&gt;이 처럼 의존관계를 외부에서 주입받는게 아니라 직접 필요한 의존 관계를 찾는 것을 Dependency Lookup(DL) 의존관계라고 한다.&lt;/p&gt;

&lt;p&gt;하지만 이렇게 스프링의 애플리케이션 컨텍스트 전체를 주입받게 되면 스프링 컨테이너에 종속적인 코드가 되고, 단위테스트도 어려워지게 된다. 무엇보다 객체지향적이지 않은 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;objectfactory-objectprovider&quot;&gt;ObjectFactory, ObjectProvider&lt;/h2&gt;

&lt;p&gt;지정한 빈을 컨테이너에서 대신 찾아주는 DL 서비스를 제공&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nd&quot;&gt;@Scope&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;singleton&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ClientBean&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ObjectProvider&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;PrototypeBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prototypeBeanProvider&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;logic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;PrototypeBean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prototypeBean&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prototypeBeanProvider&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;prototypeBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prototypeBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에서 작성했던 코드를 다음과 같이 바꿔보았다. 간단한 테스트를 위해서 필드주입으로 사용하였고, ObjectProvider를 사용하여 PrototypeBean을 직접 호출하여 호출할 때마다 새로운 객체를 받아오도록 하였다. 제네릭으로 어떤 빈을 호출할 건지를 적어주어야 한다.&lt;/p&gt;

&lt;p&gt;logic() 메서드를 보면 getObject() 메서드를 사용하여 컨테이너한테 프로토타입 빈의 새 객체를 요청한 다음 로직을 실행하는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;클라이언트가 메서드를 호출할 때마다 컨테이너는 새로운 객체를 주므로 테스트코드에서는 count의 수치가 1이 되어야 할 것이다. (테스트 성공)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;지금까지 내용을 다시 정리하자면, 생성자 주입을 할 때 프로토타입 빈을 싱글턴 빈에다가 주입하게되면 빈을 생성할 때 최초로 프로토타입 빈이 주입되고, 이후에는 싱글턴 빈을 호출할 때 주입된 프로토타입 빈만 계속 호출되어 프로토타입 빈이 싱글턴이 되어버린다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;이를 방지하기위해 ObjectProvider 객체를 사용하면 해당 객체를 getObject() 메서드를 통해서 새로운 객체를 호출할 수 있다. logic() 메서드에 getObject() 메서드를 집어넣어 메서드가 실행될 때 마다 새로운 객체를 생성해낸다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;원래는 ObjectFactory가 ObjectProvider보다 먼저 존재하고있었으나 ObjectProvider가 ObjectFactory를 상속하면서 여러가지 추가 기능들을 제공하는 객체가 만들어졌다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ObjectFactory : 기능이 단순하고 별도의 라이브러리가 필요없다. 스프링에 의존&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ObjectProvider : ObjectFactory를 상속한다. 옵션이나 스트림 처리 등 편의 기능이 많고 별도의 라이브러리가 필요없다. 스프링에 의존한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;providerjavaxinject&quot;&gt;Provider(javax.inject)&lt;/h2&gt;

&lt;p&gt;JSR-330인 자바 표준의 라이브러리이다. 라이브러리 이므로 그리들에 없다면 새로 설치를 해주어야 한다. dependencies 안에&lt;/p&gt;

&lt;p&gt;implementation ‘javax.inject:javax.inject:1’
를 작성해주면 된다.&lt;/p&gt;

&lt;p&gt;Provider라는 이름의 여러 객체들이 있으니 사용할 때는 javax.inject인지 확인하고 사용하여야 한다.&lt;/p&gt;

&lt;p&gt;ObjectProvider는 getObject()를 통해 새로운 객체를 컨테이너에 요청한다. Provider는 get() 메서드를 사용하여 컨테이너에 새 객체를 요청할 수 있다.&lt;/p&gt;

&lt;p&gt;Provider는 자바 표준이고, 기능이 매우 단순하므로 단위테스트를 만들거나 mock 코드를 만들기는 훨씬 쉬워진다.&lt;/p&gt;

&lt;p&gt;특징 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;get() 메서드 하나로 기능이 매우 단순함&lt;/li&gt;
  &lt;li&gt;별도의 라이브러리가 필요하다.&lt;/li&gt;
  &lt;li&gt;자바 표준이므로 스프링이 아닌 다른 컨테이너에서도 사용할 수 있다. (근데 이럴일이 거의 없음)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;정리&quot;&gt;[정리]&lt;/h3&gt;

&lt;p&gt;프로토타입 빈은 언제 사용할까? 매 번 사용할 때마다 의존관계 주입이 완료된 새로운 객체가 필요하면 사용하면 된다. 실무에서는 싱글턴 빈으로 대부분의 문제가 해결되기 떄문에 프로토타입 빈을 직접적으로 사용하는 일은 매우 드물다.&lt;/p&gt;

&lt;p&gt;프로토타입 뿐만 아니라 DL이 필요한 경우에는 위의 객체들을 모두 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;※ Provider, ObjectProvider 어떤걸 사용해야되는지 : ObjectProvider는 DL을 위한 편의 기능을 많이 제공해주고 스프링 외에 별도의 의존고나계 추가가 필요없기 때문에 편리하다.&lt;/p&gt;

&lt;p&gt;만약 코드를 스프링이 아닌 다른 컨테이너에서도 사용할 수 있어야 한다면 JSR-330 Provider를 사용해야한다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Achasan</name>
        
        
      </author>

      

      
        <category term="SpringBoot" />
      

      
        <summary type="html">빈 스코프 정리</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">URI/URL/URN 정의, 웹 브라우저 요청의 전체적인 흐름</title>
      <link href="https://achasan.github.io/http_basic_2" rel="alternate" type="text/html" title="URI/URL/URN 정의, 웹 브라우저 요청의 전체적인 흐름" />
      <published>2021-10-29T00:00:00+09:00</published>
      <updated>2021-10-29T00:00:00+09:00</updated>
      <id>https://achasan.github.io/http_basic_2</id>
      <content type="html" xml:base="https://achasan.github.io/http_basic_2">&lt;h1 id=&quot;http-웹-기본-지식-2&quot;&gt;HTTP 웹 기본 지식 2&lt;/h1&gt;

&lt;h2 id=&quot;uri-url-urn&quot;&gt;URI? URL? URN?&lt;/h2&gt;

&lt;p&gt;웹 공부를 하면서 URI, URL은 흔하게 들어보았으나 URN은 처음 들어봤다. 세 키워드의 차이점이 무엇인지 알아보자.&lt;/p&gt;

&lt;h3 id=&quot;uri&quot;&gt;URI&lt;/h3&gt;

&lt;p&gt;URI(Uniform Resource Identifier)는 리소스를 식별하는 통합된 방법이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Uniform : 리소스를 식별하는 통일된 방식&lt;/li&gt;
  &lt;li&gt;Resource : 자원, URI로 식별할 수 있는 모든 것(제한없음)&lt;/li&gt;
  &lt;li&gt;Identifier : 다른 항목과 구분하는데 필요한 정보&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-10-29-21-30-46.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;URI는 로케이터(locator), 이름(name) 또는 둘 다 추가로 분류될 수 있다, 즉 URI 안에 URL이 있는 것이고, URN이 있는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;url&quot;&gt;URL&lt;/h3&gt;

&lt;p&gt;URL은 Unifrom Resource Locator로, 우리가 흔히 볼 수 있는 주소창에 입력하는 그것이다. URL은 웹 애플리케이션의 리소스가 위치한 장소를 표시한다.&lt;/p&gt;

&lt;h3 id=&quot;urn&quot;&gt;URN&lt;/h3&gt;

&lt;p&gt;URN은 Unifrom Resource Name으로, 리소스에 이름을 부여한 것이다. 자주 사용되지는 않는다. 예를 들자면 책의 isbn urn을 예로 들 수 있다. 서점에 가면 뒷표지에 isbn과 바코드가 찍혀있는데, 책(리소스)의 고유한 식별자를 나타낸다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;위치는 변할 수 있지만 이름은 변하지 않는다. 하지만 URN이름 만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지는 않았다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;urluri-분석하기&quot;&gt;URL(URI) 분석하기&lt;/h2&gt;

&lt;p&gt;https://www.google.com/search?q=hello&amp;amp;hl=ko&lt;/p&gt;

&lt;p&gt;위의 URL의 구조를 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-10-29-21-35-27.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;[URL scheme]&lt;/p&gt;

&lt;p&gt;scheme://[userInfo@]host[:port][/path][?query][#fragment]&lt;/p&gt;

&lt;p&gt;https://www.google.com:443/search?q=hello&amp;amp;hl=ko&lt;/p&gt;

&lt;p&gt;[scheme] : 주로 프로토콜을 사용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로토콜 : 어떤 방식으로 자원에 접근할 것인가 하는 약속규칙(http, https, ftp 등)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https는 80포트, https는 443 포트를 주로 사용한다. 포트는 생략이 가능하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https는 http에 보안을 추가한다(HTTP Secure)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[userInfo@]&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;url에 사용자 정보를 포함해서 인증, 거의 사용하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[host]&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;호스트명. 도메인명 또는 IP주소를 직접 사용 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[Port]&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;접속 포트. 일반적으로 생략한다. 생략 시 http는 80, https는 443으로 자동설정된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[path]&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;리소스경로(path), 계층적 구조&lt;/li&gt;
  &lt;li&gt;ex) /home/file.jpg, /members, /members/100, /items/iphone12&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[?query]&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;key=value 형태로 되어있다.
?로 시작하고 &amp;amp;로 추가가 가능하다. ?keyA=valueA&amp;amp;keyB=valueB
query parameter, query string 등으로 불린다. 웹서버에서 제공하는 파라미터, 문자 형태이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[#fragment]&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;html 내부 북마크 등에 사용한다. 서버에 전송하는 정보는 아니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;웹-브라우저-요청-흐름&quot;&gt;웹 브라우저 요청 흐름&lt;/h2&gt;

&lt;p&gt;https://www.google.com/search?q=hello&amp;amp;hl=ko&lt;/p&gt;

&lt;p&gt;위의 URL 구조를 요청한다고 했을 때 전체적인 흐름을 살펴보자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;HTTPS 프로토콜을 사용한다는 점을 체크. 포트는 443으로 자동 할당된다.&lt;/li&gt;
  &lt;li&gt;호스트가 www.google.com이다. IP로 변환하니 200.200.200.2가 나옴(가정)&lt;/li&gt;
  &lt;li&gt;path = search&lt;/li&gt;
  &lt;li&gt;쿼리문 q=hello , hl=ko 로 되어있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위의 URL을 입력하게 되면 웹 브라우저는 해당 도메인 주소를 IP, 포트로 바꾸고 요청 메시지를 생성한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;GET /search?q=hello&amp;amp;hl=ko HTTP/1.1
Host: www.google.com&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-10-29-21-53-54.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;인터넷 프로토콜 4계층을 통해 HTTP 메세지가 담긴 패킷을 만들고, 서버로 전송한다.
요청 메시지를 받은 서버는 이제 해당 URL에 있는 리소스를 응답메시지로 전달해준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-10-29-21-56-06.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;응답할 메시지는 위와 같다. html을 클라이언트에 보내주면 웹 브라우저가 렌더링을 통해서 해당 URL의 화면을 출력해준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;웹-브라우저-요청-전체적인-흐름-총-정리&quot;&gt;[웹 브라우저 요청 전체적인 흐름 총 정리]&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;resource 요청 시, 웹 브라우저가 HTTP 메시지 생성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SOCKET 라이브러리를 통해 TCP/IP로 3way handshake를 실행해 서버와 연결한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;운영체제 TCP/IP 계층으로 데이터 전송을 하기 위해 데이터를 전달한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP 메시지가 포함된 TCP/IP 패킷을 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;패킷 정보가 인터넷으로 흘러간다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서버에 요청 패킷이 도착하여 패킷 껍데기는 버리고 HTTP 메시지를 서버가 해석한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP 응답 메시지를 마찬가지 방식으로 패킷을 생성하여 응답 패킷을 전달한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;수 많은 노드들을 통해서 응답 패킷이 도착하게 되면 웹 브라우저가 HTML 렌더링하여 화면에 보여준다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content>

      
      
      
      
      

      <author>
          <name>Achasan</name>
        
        
      </author>

      

      
        <category term="SpringBoot" />
      

      
        <summary type="html">HTTP 웹 기본 지식 2</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">IP 프로토콜, TCP/UDP의 정의, 특성, Port, DNS</title>
      <link href="https://achasan.github.io/http_basic_1" rel="alternate" type="text/html" title="IP 프로토콜, TCP/UDP의 정의, 특성, Port, DNS" />
      <published>2021-10-29T00:00:00+09:00</published>
      <updated>2021-10-29T00:00:00+09:00</updated>
      <id>https://achasan.github.io/http_basic_1</id>
      <content type="html" xml:base="https://achasan.github.io/http_basic_1">&lt;h1 id=&quot;http-웹-기본-지식&quot;&gt;HTTP 웹 기본 지식&lt;/h1&gt;

&lt;h2 id=&quot;인터넷-네트워크&quot;&gt;인터넷 네트워크&lt;/h2&gt;

&lt;p&gt;웹을 개발하기 위해 알아야하는 인터넷 네트워크는 크게 5가지이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인터넷 통신&lt;/li&gt;
  &lt;li&gt;IP(Internet Protocol)&lt;/li&gt;
  &lt;li&gt;TCP, UDP&lt;/li&gt;
  &lt;li&gt;PORT&lt;/li&gt;
  &lt;li&gt;DNS&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;인터넷-통신&quot;&gt;인터넷 통신&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;인터넷에서 컴퓨터 둘이 통신을한다고 가정해보자. 클라이언트가 서버에 Hello world라는 메시지를 보내려고 한다. 만약 클라이언트가 한국에 있고, 서버가 미국에 있을 때 클라이언트의 메시지는 수 많은 노드들을 거쳐 서버에 도착해야한다.&lt;/li&gt;
  &lt;li&gt;하지만 이 많은 노드들을 거쳐서 서버에 가는 동안 길을 잃지않고 목표한 지점의 서버까지 어떻게 이동할 수 있는 것일까?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ip--인터넷-프로토콜&quot;&gt;IP : 인터넷 프로토콜&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;IP의 역할은 지정한 IP주소에 데이터를 전달하는 것이다. 또한 패킷이라는 통신 단위로 데이터를 전달한다.&lt;/li&gt;
  &lt;li&gt;패킷?
    &lt;ul&gt;
      &lt;li&gt;패킷은 출발지IP, 목적지IP, 기타 정보들이 담겨있다.&lt;/li&gt;
      &lt;li&gt;클라이언트에서 Hello world 메시지를 담은 IP 패킷을 서버로 던진다. 서버는 IP패킷을 받으면 패킷을 읽는다.&lt;/li&gt;
      &lt;li&gt;서버들은 IP패킷에는 읽어오는 규약을 따르는데, 이를 통해 어떠한 클라이언트가 던진 패킷이더라도 IP 패킷을 읽을 수 있다.&lt;/li&gt;
      &lt;li&gt;읽은 패킷을 노드들끼리 던지면서 최종목적지 IP가 있는 서버로 패킷을 던져준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클라이언트의 메시지를 받은 서버는 응답 패킷을 다시 클라이언트에 던져준다. 여기서 클라이언트가 서버까지 오는 노드와는 다른 루트로 전달이 될 수 있다. 어떻게든 클라이언트의 요청에 응답하기만 하는 것이 목적이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ip-프로토콜의-한계&quot;&gt;IP 프로토콜의 한계&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;비연결성 : 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷이 전송된다.&lt;/li&gt;
  &lt;li&gt;비신뢰성 : 중간에 패킷이 사라진다면? 패킷이 순서대로 안온다면?
    &lt;ul&gt;
      &lt;li&gt;패킷의 용량이 클 경우에는 패킷을 쪼개서 순차적으로 보내야한다. 만약 1, 2, 3 순서대로 보냈는데 1, 3, 2순으로 도착했다면?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로그램 구분 불가 : 클라이언트에서 스트리밍으로 노래를 듣고, 통화를 하고, 게임을 한다고 했을 때 해당 클라이언트 아이피에서 보낸 요청이 어떤 프로그램 왔는 지 알 수 있는지?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;tcp-udp&quot;&gt;TCP, UDP&lt;/h2&gt;

&lt;p&gt;IP프로토콜은 여러 한계점을 가지고 있다. 따라서 TCP, UDP가 더 많이 쓰인다. 어떤 장점을 가지고 있을까?&lt;/p&gt;

&lt;p&gt;이를 알기 위해서는 인터넷 프로토콜 스택의 4계층을 먼저 알아야한다.&lt;/p&gt;

&lt;h3 id=&quot;인터넷-프로토콜-스택의-4계층&quot;&gt;인터넷 프로토콜 스택의 4계층&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션 계층 : HTTP, FTP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;전송계층 : TCP, UDP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;인터넷 계층 : IP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;네트워크 인터페이스 계층(랜카드, 랜드라이버 …)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-10-29-20-57-36.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 사진을 보면 4계층이 어떻게 이루어져있는지 볼 수 있다. 이제 TCP가 어떻게 전송되는지를 보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-10-29-20-58-54.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;구동중인 어플리케이션에서 Hello world라는 메시지를 생성한다.(HTTP 방식)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Socket 라이브러리를 통해 데이터를 전송계층에 보낸다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TCP 데이터를 생성한다. 메시지 데이터를 포함한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IP패킷을 생성하고 안에 TCP 데이터를 포함한다.(메시지도 같이 포함된다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;랜카드의 MAC 주소와 정보가 포함된 Ethernet frame을 생성하고 안에 TCP 데이터를 담는다(TMI)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;IP 패킷에는 출발지 IP와 목적지 IP, 기타 정보가 담겨있다. TCP에는 출발지의 Port와 목적지 Port가 담겨있고 전송 제어, 순서, 검증 정보 등이 담겨있고 그 안에 전송 데이터가 담겨져있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;tcp-특징&quot;&gt;TCP 특징&lt;/h2&gt;

&lt;p&gt;TCP(/assets/images/HTTP_imagesTransfer Control Protocol)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;연결지향 : TCP 3 way handshake(가상연결) - 먼저 상대방과 연결이 되어있는지 확인한 다음에 전송한다.&lt;/li&gt;
  &lt;li&gt;데이터 전달 보증 : 클라이언트에서 데이터를 전송하면 서버에서 데이트를 받았다고 회신해준다. 클라이언트에서는 데이터가 전달되었다는 점을 확인 가능하다.&lt;/li&gt;
  &lt;li&gt;순서 보장 : 패킷을 1, 2, 3 순서로 전송했는데 1, 3, 2 순서로 도착했을 경우 서버에서 패킷 2부터 다시 보내라고 응답한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 3가지 특징으로 인해 TCP는 신뢰할 수 있는 프로토콜이 되었다. 현재는 대부분 TCP를 사용한다. 이제 각 특징에 대해 자세히 알아보자.&lt;/p&gt;

&lt;h3 id=&quot;1-tcp-3-way-handshake-&quot;&gt;1. TCP 3 way handshake &lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-10-29-21-05-43.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;클라이언트가 서버에 SYN이라는 신호를 보낸다.&lt;/li&gt;
  &lt;li&gt;SYN 신호를 받은 서버가 클라이언트에 SYN + ACK 신호를 보낸다.&lt;/li&gt;
  &lt;li&gt;SYN + ACK 신호를 받은 클라이언트가 ACK 신호를 서버에 보낸다.&lt;/li&gt;
  &lt;li&gt;클라이언트가 서버로 데이터를 전송한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;여기서 SYN은 접속을 요청하는 신호이다. 클라이언트가 접속을 요청하면 서버는 접속요청과 요청 수락 신호를 같이 보낸다. 클라이언트는 요청 수락 신호를 보내게 되면 서로 연결이 가능하다는 뜻이므로 그제서야 클라이언트는 데이터를 전송하기 시작한다. (ACK 신호를 보내면서 같이 전송하기도 한다.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-데이터-전달-보증&quot;&gt;2. 데이터 전달 보증&lt;/h3&gt;

&lt;p&gt;TCP는 클라이언트가 데이터를 서버에 보내면 서버에서 데이터를 받았다는 응답을 보낸다. IP 패킷의 경우에는 클라이언트가 데이터를 보내도 서버에서 받았다는 응답을 받지 못한다. 클라이언트에서는 데이터가 제대로 전송이 되었는 지 알 수가 없다. 신뢰성을 보장받지 못한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-순서-보장&quot;&gt;3. 순서 보장&lt;/h3&gt;

&lt;p&gt;클라이언트에서 TCP 프로토콜로 패킷을 쪼개서 1, 2, 3 순으로 보냈는데 1, 3, 2순으로 서버에 도착했다. 이럴 경우 서버에서는 TCP 정보를 읽고, 순서가 다르게 보내진 점을 인지하고 클라이언트에게 2번 패킷부터 다시 보내라고 응답을 보내게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;udp-특징&quot;&gt;UDP 특징&lt;/h2&gt;

&lt;p&gt;사용자 데이터그램 프로토콜(User Datagram Protocol)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;UDP는 하얀 도화지에 비유할 수 있다.(기능이 거의 없음)&lt;/li&gt;
  &lt;li&gt;TCP의 3way handshake 같은 연결지향적인 기능이 없다.&lt;/li&gt;
  &lt;li&gt;데이터 전달 보증이 안된다.&lt;/li&gt;
  &lt;li&gt;순서 보장이 안된다.&lt;/li&gt;
  &lt;li&gt;하지만 구조가 단순하고 빠르다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;UDP는 IP와 거의 같다고 보면 된다. 하지만 여기에 Port 정보와 체크섬 정보는 포함하고 있는게 차이점이다. 따라서 UDP를 사용하기 위해서는 애플리케이션에서 추가작업이 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;port&quot;&gt;Port&lt;/h2&gt;

&lt;p&gt;TCP에 담기는 정보중에 Port가 있었다. port에 대해서 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-10-29-21-14-13.png&quot; alt=&quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;클라이언트가 게임, 화상통화, 웹 브라우저 각각 다른 프로그램들을 사용중이다. IP 프로토콜의 경우에는 요청을 보내도 IP만 적혀있어 어떤 프로그램에서 온 요청인지를 알 수 없다. 게임과 화상통화는 같은 서버를 공유하고 있어서 어느쪽으로 응답을 보내야될지 서버측에서 알 방법이 없다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-10-29-21-19-49.png&quot; alt=&quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 사진은 TCP와 IP 패킷을 합친 것이다. TCP/IP에는 출발지 PORT, 목적지 PORT가 포함되어 있는데 아이피 뒤에 :0000 방식으로 붙여져 있다. 프로그램마다 포트번호를 다르게 해서 어디서 온 요청인지 구분할 수 있게 해준다.&lt;/p&gt;

&lt;h3 id=&quot;port-특징-&quot;&gt;Port 특징 &lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;Port는 항구라는 뜻을 가지고 있다. IP가 아파트라면, Port는 동, 호수를 의미한다. 포트를 통해 어떤 애플리케이션에서 온 요청인지 구분짓고, 서버에스는 해당 포트로 다시 응답해주면 되어 데이터가 충될되지 않게 해준다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;0 ~ 65535 할당 가능&lt;/li&gt;
  &lt;li&gt;0 ~ 1023 : 잘 알려진 포트로 사용하지 않는 것이 좋다.
    &lt;ul&gt;
      &lt;li&gt;FTP : 20, 21&lt;/li&gt;
      &lt;li&gt;TELNET : 23&lt;/li&gt;
      &lt;li&gt;HTTP : 80&lt;/li&gt;
      &lt;li&gt;HTTPS : 443&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;dns-domain-name-system&quot;&gt;DNS (Domain Name System)&lt;/h2&gt;

&lt;p&gt;ip 주소는 숫자로 되어있어 기억하기가 어렵고 입력하기도 번거롭다. 또한 유동적인 ip를 사용할 경우에는 ip의 값이 변경될 수도 있다. 이렇게 될 경우 개발할 때 새로운 아이피 주소를 다시 작성해주어야 한다.&lt;/p&gt;

&lt;p&gt;이러한 단점을 보완하기위해 DNS가 등장하였다. DNS는 전화번호부라고 볼 수 있는데, IP 주소를 도메인 명으로 변환하는 시스템이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/HTTP_images/2021-10-29-21-27-13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Achasan</name>
        
        
      </author>

      

      
        <category term="SpringBoot" />
      

      
        <summary type="html">HTTP 웹 기본 지식</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">[Spring:7] 조회한 빈이 모두 필요할 때</title>
      <link href="https://achasan.github.io/spring_basic_7" rel="alternate" type="text/html" title="[Spring:7] 조회한 빈이 모두 필요할 때" />
      <published>2021-10-28T00:00:00+09:00</published>
      <updated>2021-10-28T00:00:00+09:00</updated>
      <id>https://achasan.github.io/spring_basic_7</id>
      <content type="html" xml:base="https://achasan.github.io/spring_basic_7">&lt;h1 id=&quot;의존관계-자동-주입-2-이전링크&quot;&gt;의존관계 자동 주입 2 &lt;a href=&quot;20211028_4.md&quot;&gt;이전링크&lt;/a&gt;&lt;/h1&gt;

&lt;h2 id=&quot;조회한-빈이-모두-필요할-때-list-map&quot;&gt;조회한 빈이 모두 필요할 때, List, Map&lt;/h2&gt;

&lt;p&gt;동적으로 필요한 할인정책을 그때그때 선택하여 사용할 수 있도록 하는 방법을 알아보자.&lt;/p&gt;

&lt;p&gt;비즈니스 로직 처리는 Service 클래스에서 하므로 Service 클래스에 Map 객체 또는 List 객체에 빈을 넣어서 사용하면 된다. 당연히 AutoWired를 통해서 빈 객체를 넣을 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AllBeanTest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findAllBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ac&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnnotationConfigApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AutoAppConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;nc&quot;&gt;DiscountService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ac&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DiscountService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;userA&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Grade&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;VIP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPrice&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;discount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;rateDiscountPolicy&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;discountService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isInstanceOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DiscountService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;discountPrice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isEqualTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;policyMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;policies&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;DiscountService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;policyMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
             &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;policies&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;policyMap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;policyMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;policies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;policies&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;discount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;price&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;policyMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;discountCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;discount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;price&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;먼저 정적 클래스를 하나 만들었다. DiscountService 클래스인데, 빈으로 등록되어있는 모든 DiscountPolicy 타입의 구현체들을 키와 값의 형태로 Map 컬렉션에 넣도록 생성자 주입까지 작성하였다.&lt;/p&gt;

&lt;p&gt;그리고 AnnotationConfigApplicationContext 객체를 통해 DiscountPolicy.class, DiscountService.class 클래스 파일을 빈에 등록했다.&lt;/p&gt;

&lt;p&gt;(이미 ComponentScan을 통해서 빈에 등록되어있는 경우에는 빈의 설정정보를 그냥 가져온다.)&lt;/p&gt;

&lt;p&gt;이렇게 될 경우, DiscountService에 있는 생성자를 보고 스프링이 DiscountPolicy에 해당하는 구현체 빈 클래스들을 Map 컬렉션에 하나씩 넣어주게 된다. 순서는 랜덤이다.&lt;/p&gt;

&lt;p&gt;여기서 키 값이 어떻게 들어가지는지 궁금해질 텐데, 기본적으로 등록되는 빈 이름이 된다. FixDiscountPolicy는 fixDiscountPolicy로, RateDiscountPolicy는 rateDiscountPolicy로 빈 이름이 등록되어진다. key는 생성된 빈 이름이 들어가고, 싱글턴 방식으로 등록된 객체주소를 value값으로 받아와서 Map 객체 안에 들어가게 된다.&lt;/p&gt;

&lt;p&gt;이제 로직을 만들고 Assertion으로 테스트코드를 확인해보자.
DiscountService 클래스에는 discount 메서드가 있다. 파라미터로는 멤버변수, 가격과 discountCode가 있다. discountCode는 Map 객체에 있는 key를 입력하면 된다. rateDiscountPolicy를 입력하면 rateDiscountPolicy 객체에 있는 discount 메서드를 실행한 결과값을 리턴하도록 설정하고 리턴하도록 하였다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;자동-수동의-올바른-실무-운영-기준&quot;&gt;자동 수동의 올바른 실무 운영 기준&lt;/h2&gt;

&lt;p&gt;빈을 등록하는 방법은 다양하다. 하지만 어떤 상황에 자동 빈을 쓰고, 수동 빈을 써야할지는 감이 잡히지 않는다. 그래서 뭘 어떻게 쓰라는건데?&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;편리한-자동-기능을-기본으로-사용하자&quot;&gt;편리한 자동 기능을 기본으로 사용하자.&lt;/h3&gt;

&lt;p&gt;스프링이 나오고 난 이래 자동이 점점 선호되는 추세이다. 스프링은 계층에 맞추어 일반적인 애플리케이션 로직을 자동으로 스캔할 수 있도록 지원한다. 또한 스프링 부트는 컴포넌트 스캔을 기본으로 사용하고 다양한스프링 빈들도 조건이 맞으면 자동으로 등록하도록 설계되었다.&lt;/p&gt;

&lt;p&gt;설정 정보를 기반로 구성하는 부분과 실제 동작하는 부분을 명확히 나누느 것이 이상적이지만 주입할 대상을 일일이 적어주는 과정은 상당히 번거롭다.&lt;/p&gt;

&lt;p&gt;결정적으로 자동 빈 등록을 사용해도 OCP, DIP를 지킬 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 수동 빈 등록은 언제 사용하는 것일까?&lt;/p&gt;

&lt;p&gt;애플리케이션은 크게 업무 로직과 기술지원 로직으로 나눌 수 있다.&lt;/p&gt;

&lt;p&gt;업무 로직 빈은 웹을 지원하는 컨트롤러, 핵심 비즈니스 로직이 있는 서비스, 데이터 계층의 로직을 처리하는 리포지토리 등이 모두 업무 로직이다. 비즈니스 요구사항을 개발할 때 추가되거나 변경된다.
기술지원 빈은 기술적인 문제나 공통 관심사(AOP)를 처리할 떄 주로 사용된다. DB 연결이나 공통 로그 처리처럼 업무 로직을 지원하기 위한 하부 기술이나 공통 기술들이다.&lt;/p&gt;

&lt;p&gt;업무 로직은 그 수가 많고, 한번 개발하게되면 컨트롤러, 서비스, 리포지토리 처럼 유사한 패틴 있다. 이 경우는 자동기능을 적극적으로 사용하는 것이 좋다. 보통 문제가 발생해도 어디서 발생했는지 파악하기가 어렵지 않다.
기술로직은 그 수가 상대적으로 업무로직보다 적고, 어플리케이션 전반에 걸쳐서 고아범위하게 영향을 미친다. 기술 지원 로직은 적용이 잘 되고 있는지 아닌지 조차 파악하기 어려운 경우가 많다. 따라서 기술지원 로직은 가급적 수동 빈 등록을 사용해서 명확하게 드러내는 것이 좋다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“어플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈으로 등록해서 설정 정보에 바로 나타나게 하는 것이 유지보수에 좋다.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;한 가지 고민해봐야할 점이 하나 있는데, 추상화이다.&lt;/p&gt;

&lt;p&gt;추상화는 내가 개발할 때는 정말 편리하고 좋지만, 내가 작성한 코드를 다른 동료개발자가 봤을 때 한 눈에 알아보기 힘들다는 단점이 있다.&lt;/p&gt;

&lt;p&gt;예를들어 이전강의에서 DiscountService 클래스를 생각해보자 Map 객체에 DiscountPolicy 타입의 빈들이 전부 담겨진다. 우리는 rateDiscountPolicy, fixDiscountPolicy를 만들어 봐서 어떤 빈이 들어갈지 알 수 있다. 하지만 다른 동료개발자들은 처음 코드를 봤을 때 어떤 객체가 Map 컬렉션에 담기는지 한 눈에 알아보기 힘들다.&lt;/p&gt;

&lt;p&gt;담기는 빈 객체들이 몇 십개 된다면 과연 동료개발자가 내 코드를 파악하고 제대로 개발을 수행할 수 있을까? 사실 정답은 없다. AppConfig를 통해서 수동으로 빈을 등록하면 가독성은 좋아지지만 번거로운 작업이 될 것이다.&lt;/p&gt;

&lt;p&gt;따라서 추상객체와 구현체들이 같은 타입인 경우에는 패키지에 따로 모아두는 것이 좋다. 다른 개발자가 딱 보고 어떻게 구성되어있는지를 파악할 수 있도록 설계하는 것이 핵심이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;p&gt;편리한 자동 기능을 기본으로 사용하자.&lt;/p&gt;

&lt;p&gt;직접 등록하는 기술 지원 객체는 수동 등록을 하는 것이 좋다.&lt;/p&gt;

&lt;p&gt;다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민해보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;※ @Bean과 @Component의 차이&lt;/p&gt;

&lt;p&gt;@Bean은 수동 빈 등록을 하기 위해서 사용하는 어노테이션이다. @Configuration으로 등록한 설정 정보 클래스의 메서드에 @Bean을 입력하면 컨테이너에 수동으로 등록이 된다.&lt;/p&gt;

&lt;p&gt;@Component는 자동으로 빈 등록을 하기 위해서 사용되는 어노테이션이다. @ComponentScan이 되어있는 자동 설정정보 클래스가 있으면 모든 @Component 클래스를 스캔해서 컨테이너에 등록한다.&lt;/p&gt;

&lt;p&gt;@Bean은 수동 빈 등록, @Component는 자동 빈 등록이라는 점을 구분짓기 위해서 사용한다. 만약 @Configuration 클래스에 @Component를 사용하면 수동 빈으로 등록하려는 메서드를 자동 빈 등록으로 한다는 점이 충돌되어서 예외가 발생하게 된다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Achasan</name>
        
        
      </author>

      

      
        <category term="SpringBoot" />
      

      
        <summary type="html">의존관계 자동 주입 2 이전링크</summary>
      

      
      
    </entry>
  
</feed>
