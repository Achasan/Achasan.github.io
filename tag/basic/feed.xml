<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://achasan.github.io/tag/basic/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://achasan.github.io/" rel="alternate" type="text/html" />
  <updated>2021-12-28T11:20:06+09:00</updated>
  <id>https://achasan.github.io/tag/basic/feed.xml</id>

  
  
  

  
    <title type="html">Memory Repo. | </title>
  

  
    <subtitle>by Achasan</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">PL/SQL, 데이터 정의어(DDL)</title>
      <link href="https://achasan.github.io/database_6" rel="alternate" type="text/html" title="PL/SQL, 데이터 정의어(DDL)" />
      <published>2021-09-07T00:00:00+09:00</published>
      <updated>2021-09-07T00:00:00+09:00</updated>
      <id>https://achasan.github.io/database_6</id>
      <content type="html" xml:base="https://achasan.github.io/database_6">&lt;h1 id=&quot;plsql-procedual-language--structured-query-language&quot;&gt;PL/SQL (Procedual Language / Structured Query Language)&lt;/h1&gt;

&lt;p&gt;SQL만으로는 구현이 어렵거나 구현이 불가능한 작업을 수행하기 위해서 오라클에서
제공하는 프로그래밍 언어를 말한다.
일반 프로그래밍 언어적인 요소들을 가지고 있으며, 데이터베이스 업무를 처리하기위한
최적화된 언어이다.
변수 선언, 조건문, 반복문 등 다양한 기능들을 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;기본 구조는 선언부, 실행부, 예외처리부로 나뉘어져 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;선언부(Declare) : 선언부는 모든 변수나 상수를 선언하는 부분이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;실행부(Excutable - begin) : 실제 로직이 실행되는 부분으로, 제어문(조건문), 반복문 등의 로직을 기술한다. Java로 따지자면 Main문 정도가 되는듯 하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;예외처리부(Exception) : 실행 도중 예외가 발생 시 해결하기위한 명령들을 기술하는 부분이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;기본 구조 중에서 선언부와 예외처리부는 생략이 가능하지만 실행부는 반드시 기술하여야 한다.
또한 기본구조 키워드 뒤에는 세미콜론을 붙이지 않는다, 단, 블럭 내의 각 실행문장 끝에는 세미콜론을 붙인다.
BEGIN ~ END(실행부) 밑에는 반드시 ‘/’를 붙여주어야 한다. END 뒤에는 세미콜론을 붙여준다.&lt;/p&gt;

&lt;p&gt;이전에 그룹함수와 DECODE 함수를 혼자 공부해서 배운적이 있었는데 이 함수들은 PL/SQL 내에서 단독으로 사용이 불가능하다.
SQL문장에 포함되어서 사용되기 때문에 혼동해서는 안된다. PL/SQL문에서는 자바처럼 IF, FOR, WHILE 문을 사용할 수 있다.
각 문장과 함수의 용도를 구별해서 사용해야하며, 무분별하게 의미가 같다고 해서 사용하면 에러가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;한 가지 더 알아두어야할 점은, PL/SQL은 기본적으로 문장의 결과를 화면에 출력시키지 않기 때문에,
결과값이 화면에 나오도록 설정하기 위해서는 SET SERVEROUTPUT ON 키워드를 사용하여 출력을 활성화시켜주어야한다.&lt;/p&gt;

&lt;p&gt;예시 문장을 보자,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;    DECLARE
        NUM NUMBER(2);
        NAME VARCHAR2(20);
    BEGIN
        SELECT EMPNO, ENAME INTO NUM, NAME
        FROM EMP
        WHERE ENAME = 'ADAMS';

        DBMS_ OUTPUT.PUT_LINE(NUM||'        '||NAME);
    END;
    /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;선언부(DECLARE)에서 NUM과 NAME 변수를 선언하고, 실행부(BEGIN)에서 EMP 테이블에 있는 EMPNO와 ENAME 컬럼의 데이터를 선언한 변수에
저장하였다. 조건으로는 이름이 ‘ADAMS’인 사원의 사번과 이름으로 조건을 걸었다.
마지막 문장에 DBMS_OUTPUT.PUT_LINE() 함수를 볼 수있는데 이는 JAVA의 System.out.println()과 의미가 같은 함수이다.
결과값을 출력하는 함수이다. 사번과 이름을 스크립트에 출력시키기 위해서 함수를 사용하였다.
PL/SQL이 끝났을 떄는 END와 세미콜론을 붙이고, 다음줄에 ‘/’를 써야한다.&lt;/p&gt;

&lt;h2 id=&quot;자료형-타입&quot;&gt;자료형 타입&lt;/h2&gt;

&lt;p&gt;선언부에 선언한 변수의 자료형을 ‘스칼라 자료형’이라고 한다.
주로 사용하는 자료형의 종류로는 스칼라 자료형, REFERENCE 자료형, ROWTYPE 자료형이 있다.
스칼라 자료형은 인스턴스 자료형과 비슷하다. PL/SQL에서 사용되기 위해 선언된 변수로, 실행문이 종료되면 변수에 있던
데이터 값은 사라진다.&lt;/p&gt;

&lt;p&gt;REFERENCE 자료형은 테이블 내의 컬럼이 가진 자료형타입을 그대로 참조해서 사용하는 자료형이다.
선언부에 NUM EMP.EMPNO%TYPE 이런 식으로 사용한다. NUM이라는 변수를 선언하고, 자료형을 EMP 테이블에 있는 EMPNO 컬럼의 자료형과
똑같이 하겠다는 뜻이 된다.&lt;/p&gt;

&lt;p&gt;ROWTYPE 자료형은 변수에 테이블에 있는 모든 컬럼들을 한꺼번에 저장하기 위한 자료형으로 선언하는 것을 말한다.
선언부에 EMP_ROW EMP%ROWTYPE 과 같은 형식으로 사용한다. EMP_ROW는 EMP테이블에 있는 행 하나를 완전히 담을 수 있게 된다.
주의해야할 점은 EMP_ROW는 행 하나만 저장이 가능하다. 여러 개의 행을 저장하고 출력하려고 할 경우 에러가 발생한다.&lt;/p&gt;

&lt;h2 id=&quot;조건-제어문&quot;&gt;조건 제어문&lt;/h2&gt;

&lt;h3 id=&quot;if문&quot;&gt;IF문&lt;/h3&gt;

&lt;p&gt;PL/SQL에서도 당연히 조건 제어문을 지원한다. 크게 3가지의 조건문으로 구성되어있는데,
IF~THEN, IF~THEN~ELSE, IF~THEN~ELSIF 이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;IF~THEN
JAVA에서는 ‘IF(조건식){ 실행문; }’ 방식으로 되어있다면
PL/SQL에서는 ‘IF 조건식 THEN 실행문; END IF;’ 방식으로 되어있다.
괄호는 일절 쓰지 않으며, THEN과 END IF로 문장의 끝을 구분한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IF~THEN~ELSE
IF~THEN에서 작성한 조건문에 ELSE를 하나 더 넣는 방식이다. ELSE는 당연히 조건식이 거짓일 때
실행되어질 문장을 말한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IF~THEN~ELSIF
여러 개의 조건식을 추가할 수 있는 조건식이다. JAVA에서는 ELSE IF 를 사용하여 조건문을 추가했었다.
이와 똑같은 방식으로 사용한다. 다만 주의해야할 점은 키워드가 ELSIF로 사용된다는 점이다.
ELSE IF가 아니라 ELSIF여서 처음에는 많이 헷갈릴 수 있으니 조심해야한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;    DECLARE
        V_AVG NUMBER(5, 2) := 89.12;
    BEGIN
        IF V_AVG &amp;gt;= 90 THEN
            DBMS_OUTPUT.PUT_LINE('A');
        ELSIF V_AVG &amp;gt;= 80 THEN
            DBMS_OUTPUT.PUT_LINE('B');
        ELSIF V_AVG &amp;gt;= 70 THEN
            DBMS_OUTPUT.PUT_LINE('C');
        ELSIF V_AVG &amp;gt;= 60 THEN
            DBMS_OUTPUT.PUT_LINE('D');
        ELSE
            DBMS_OUTPUT.PUT_LINE('F');
        END IF;
    END;
    /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자바에서 구현했었던 학점 출력문을 PL/SQL로 구현한 모습이다. ELSIF문을 사용했을 때도 뒤에 THEN을 붙이는 것이 포인트이고,
ELSE 문에는 THEN을 붙이지 않는다. 애초에 ELSE문 뒤에는 조건식이 나오지 않기 때문에 THEN을 붙일 필요도 없다.
마지막은 꼭 END IF;로 조건문을 마무리해주도록 하자.&lt;/p&gt;

&lt;p&gt;여기서 중요한 점이 한 가지 있는데 선언부에서 V_AVG 변수에 값을 저장한 것이다. 변수에 값을 저장할 때는
무조건 ‘:=’를 사용해주어야 한다는 점을 잊지말자.&lt;/p&gt;

&lt;h3 id=&quot;case문&quot;&gt;CASE문&lt;/h3&gt;

&lt;p&gt;CASE문은 Java에서 SWITCH 문과 기능이 같다. CASE 조건문은 크게 2가지로 나뉘어져 있는데,
단순 CASE문과 검색 CASE문이다. 단순 CASE문은 CASE문의 기준이 되는 데이터 값에 따라 실행되는 문장이 달라지는 것이고,
검색 CASE문은 기준 데이터값이 없고, 여러 조건식만 존재하는 CASE 문이다. 검색 CASE문의 경우에는 IF~THEN~ELSIF 조건문을
좀 더 효율적으로 작성하기 위해서 만들어진 CASE문이라고 생각하면 될 것 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;    DECLARE
        V_SCORE NUMBER(3) := 88;
    BEGIN
        CASE
            WHEN V_SCORE &amp;gt;= 90 THEN
                DBMS_OUTPUT.PUT_LINE('A');
            WHEN V_SCORE &amp;gt;= 80 THEN
                DBMS_OUTPUT.PUT_LINE('B');
            WHEN V_SCORE &amp;gt;= 70 THEN
                DBMS_OUTPUT.PUT_LINE('C');
            WHEN V_SCORE &amp;gt;= 60 THEN
                DBMS_OUTPUT.PUT_LINE('D');
            ELSE
                DBMS_OUTPUT.PUT_LINE('F');
        END CASE;
    END;
    /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;검색 CASE문의 예시를 작성해보았다. 방금 IF~THEN~ELSIF 문에서 작성한 것과 내용면에서 큰 차이는 없다.
다만 키워드가 CASE, WHEN으로 달라졌을 뿐이다. 쉽게 이해가 가능하여 여기까지 설명하도록 한다.&lt;/p&gt;

&lt;h3 id=&quot;반복-제어문&quot;&gt;반복 제어문&lt;/h3&gt;

&lt;p&gt;반복 제어문은 특정 작업을 반복하여 수행하고자할 때 사용하는 문장으로,
기본 LOOP, WHILE LOOP, FOR LOOP 세 가지의 반복 제어문을 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;세 가지의 반복 제어문을 설명하기 전에 PL/SQL에서는 반복문의 반복 수행을 종료시키는 명령어가 있다.
반복문을 제어할 때 필요한 키워드이니 반드시 알아두도록 하자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;EXIT : 수행중인 반복을 종료시키는 명령어&lt;/li&gt;
  &lt;li&gt;EXIT-WHEN : 반복 종료를 위한 조건식을 지정하고 만족하면 반복을 종료&lt;/li&gt;
  &lt;li&gt;CONTINUE : 수행중인 반복의 현재 주기를 건너 띔&lt;/li&gt;
  &lt;li&gt;CONTINUE-WHEN : 특정 조건식을 지정하고 조건식을 만족하면 반복 주기를 건너띔&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이제 반복제어문을 하나씩 알아보자,&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;기본 LOOP : 기본 LOOP는 단순이 반복을 진행시키는 반복문이다. 따라서 반복문 안에 반복문을 종료시키는 명령어를 추가시켜주어야 한다. 아래 예제를 보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;    DECLARE
        V_NUM NUMBER(3) := 1;
        V_SUM NUMBER(5) := 0;
    BEGIN
        LOOP
            IF V_NUM = 100 THEN
                V_SUM := V_SUM + V_NUM;
                DBMS_OUTPUT.PUT_LINE(V_SUM);
                EXIT;
            ELSE
                V_SUM := V_SUM + V_NUM;
                V_NUM := V_NUM + 1;
            END IF;
        END LOOP;
    END;
    /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1부터 100까지의 합을 구하는 반복문을 LOOP문을 사용하여 구한 식이다. 만약 V_NUM이 100보다 크거나 같을 경우에
V_SUM에 V_NUM의 값을 더하고 V_SUM을 출력한 후 반복문을 종료시켰다. V_NUM이 100이 아니라면 V_SUM에 값을 더하고 반복문을
계속 진행시키도록 하였다.&lt;/p&gt;

&lt;p&gt;코드를 조금 더 간결하게 바꾸어보자. 위에 제시한 4가지의 반복문을 제어하는 키워드를 통해 줄여볼 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;    DECLARE
        V_NUM NUMBER(3) := 1;
        V_SUM NUMBER(5) := 0;
    BEGIN
        LOOP
            V_SUM := V_SUM + V_NUM;
            V_NUM := V_NUM + 1;
            EXIT WHEN V_NUM &amp;gt; 100;
        END LOOP;
        DBMS_OUTPUT.PUT_LINE(V_SUM);
    END;
    /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;코드가 복잡하기 때문에 코드를 간소화 시켰다. 여기서 주목해야할 부분은 EXIT WHEN 이다.
V_NUM이 100보다 클 경우에 루프를 나가도록 EXIT WHEN 키워드를 사용했고, 반복문을 빠져나오면 V_SUM을 출력하도록 하였다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;WHILE LOOP : 조건식을 만족할 때까지 계속 반복문을 돌리는 것이다 Java에서 배웠던 WHILE문과 같다.
사용법만 간단히 보고 넘어간다.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;    DECLARE
        V_NUM NUMBER(3) := 1;
    BEGIN
        DBMS_OUTPUT.PUT_LINE('WHILE LOOP 반복문');
        WHILE V_NUM &amp;lt;= 100 LOOP
            DBMS_OUTPUT.PUT_LINE(V_NUM);
            V_NUM := V_NUM + 1;
        END LOOP;
    END;
    /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;‘WHILE 조건식 LOOP’ 형태로 작성한다. 조건식을 만족할 때 까지 반복문을 사용하며, 예시에서는 V_NUM이 100이 되는 순간
반복문을 빠져나오게 되는 형태이다. 문장 작성방식만 다를 뿐 Java와 사용방법이 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;FOR LOOP : 반복할 횟수를 정하고 반복문을 돌린다. WHILE문은 조건식을 만족할 때까지 계속 반복문을 돌린다면, FOR 반복문은 반복 횟수가 정해져있다. 이것도 Java와 공통적인 특징이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;    BEGIN
        DBMS_OUTPUT.PUT_LINE('FOR LOOP 반복문');

        FOR I IN 1 .. 100 LOOP
            DBMS_OUTPUT.PUT_LINE('I = ' || I);
        END LOOP;
    END;
    /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이번엔 선언부(DECLARE) 없이 예시를 작성하였다. 1부터 100까지 스크립트에 출력하는 반복문을 만든 것인데,
FOR 반복문을 선언하는 부분을 보면 ‘FOR 정수 IN 숫자1 .. 숫자N LOOP’ 으로 되어있다.
시작할 정수의 변수를 선언하고, IN 키워드를 작성한 다음 시작숫자 .. 최대숫자 LOOP으로 이루어져 있다.
‘..’은 ~부터 ~까지의 뜻을 가지고 있어서 1부터 100까지 하나씩 I의 수를 증가시킨다는 뜻으로 보면 된다.
FOR 반복문은 Java와는 다소 다른 형태로 되어있으므로 제대로 이해하고 넘어가는 것이 중요하다.&lt;/p&gt;

&lt;p&gt;CONTINUE는 조건식에 해당할 경우 그 반복문은 건너뛰도록 하는 키워드이다. 자바에서 사용한 continue와 동일하므로 이하 생략
CONTINUE는 IF문 같이 조건식 아래에 해당하지만 IF문을 쓰지 않아도 되도록 CONTINUE WHEN 키워드를 제공한다.
사용방법은 EXIT WHEN과 동일하여 자세한 설명은 생략한다.&lt;/p&gt;

&lt;h2 id=&quot;키보드로-값-입력-받기&quot;&gt;키보드로 값 입력 받기&lt;/h2&gt;

&lt;p&gt;Java에서는 Scanner 클래스나 BufferedReader 클래스를 이용하여 키보드로 데이터를 입력받아 코드 실행을 했었다.
PL/SQL에서도 키보드로 데이터를 입력받는게 가능한데, ‘&amp;amp;’를 사용하면 손쉽게 데이터를 입력받을 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;    CREATE TABLE TEST(
        NO NUMBER(3) PRIMARY KEY,
        NAME VARCHAR2(20) NOT NULL,
        ADDR VARCHAR2(100) NOT NULL
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;먼저 예제를 만들기 위해서 사용할 TEST 테이블을 만들었다. 컬럼은 NO, NAME, ADDR로 구성되어있고, NO가 기본키, 나머지는
NOT NULL 제약조건을 가지고 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;    DECLARE
        NO TEST.NO%TYPE;
        NAME TEST.NAME%TYPE;
        ADDR TEST.ADDR%TYPE;
        ROW TEST%ROWTYPE;
    BEGIN
        NO := '&amp;amp;NO';
        NAME := '&amp;amp;NAME';
        ADDR := '&amp;amp;ADDR';

        INSERT INTO TEST VALUES(NO, NAME, ADDR);
        SELECT * INTO ROW FROM TEST WHERE NO = NO;
        DBMS_OUTPUT.PUT_LINE('번호 /  이름  /  주소');
        DBMS_OUTPUT.PUT_LINE(ROW.NO ||' ' || ROW.NAME || ' ' || ROW.ADDR);

    END;
    /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;먼저 선언부에서 NO, NAME, ADDR, ROW 변수를 선언하였다. 자료형은 TEST 테이블에 있는 컬럼의 자료형을 참조하였다.
실행부를 보면 각 컬럼의 데이터 값을 저장하려하는데 ‘&amp;amp;변수명’이 사용된 것을 볼 수 있다.
‘&amp;amp;변수명’을 작성하면 해당 변수의 자료형에 맞도록 키보드로 데이터 값을 입력받는다는 것을 뜻한다.
입력받은 데이터 값을 각 변수에 저장하여 INSERT 쿼리문을 사용하여 TEST 테이블에 새로운 행을 추가하였다.
새로운 행을 추가하고 ROW 변수에 새로 생성한 행을 불러오고, 출력한 예제이다.&lt;/p&gt;

&lt;p&gt;중요한 점은 ‘&amp;amp;변수명’을 통해 키보드로 값을 불러올 수 있다는 점이다. 잘 기억해두도록 하자.&lt;/p&gt;

&lt;h1 id=&quot;데이터-정의어ddl--data-definition-language&quot;&gt;데이터 정의어(DDL : Data Definition Language)&lt;/h1&gt;

&lt;p&gt;DDL은 데이터의 관리 및 보관을 위해 다양한 객체를 제공하는데 이러한 객체를
새로 만들거나 기존에 존재하던 객체를 변경하거나 삭제하는 등의 기능을 수행하는 명령어를 말한다.&lt;/p&gt;

&lt;p&gt;데이터 정의어를 사용할 때 주의사항이 있는데,
데이터 정의어를 실행하면 자동으로 COMMIT이 된다는 점,
따라서 ROLLBACK을 통한 취소가 불가능하다는 점이 있다.&lt;/p&gt;

&lt;p&gt;데이터 정의어의 종류로는 CREATE, ALTER, DROP이 있다. 여태까지 사용해왔던 쿼리문이 DDL이라고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;이 외에도 다양한 데이터 정의어가 있지만 나중에 필요할 때 따로 독학해야할 것 같다. 수업에서는 중요도 높은 DDL만 설명하는듯 하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RENAME : 테이블의 이름을 변경하고 싶을 때 사용하는 명령어&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;    RENAME DEPT_02 TO DEPT_10; --'RENAME 기존이름 TO 바꿀이름'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 형식으로 입력한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DROP : 테이블을 삭제하는 명령어이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;    DROP TABLE TEST; --테스트 테이블을 삭제한다.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;TRUNCATE : 테이블의 데이터를 삭제하는 명령어(데이터를 자른다고 표현한다)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;    TRUNCATE TABLE DEPT_02; --'TRUNCATE TABLE 테이블이름'
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;PURGE : 데이터를 완전히 삭제하는 키워드이다. DELETE문에서 보통 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;    DELETE TABLE TEST;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 명령어를 입력했을 때 TEST라는 테이블이 삭제된다. 하지만 완전히 삭제된 것은 아니다.
휴지통과 같은 공간에 테이블이 넘어가있는 상태로, 원할 때 ROLLBACK으로 복구가 가능하다.
테이블을 완전히 삭제해버리기 위해서는 DELETE TABLE TEST PURGE;와 같이 작성하면 완전한 삭제가 가능하다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Achasan</name>
        
        
      </author>

      

      
        <category term="Basic" />
      

      
        <summary type="html">PL/SQL (Procedual Language / Structured Query Language)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">제약조건과 시퀀스 부연설명, 서브쿼리, 트랜잭션</title>
      <link href="https://achasan.github.io/database_5" rel="alternate" type="text/html" title="제약조건과 시퀀스 부연설명, 서브쿼리, 트랜잭션" />
      <published>2021-09-06T00:00:00+09:00</published>
      <updated>2021-09-06T00:00:00+09:00</updated>
      <id>https://achasan.github.io/database_5</id>
      <content type="html" xml:base="https://achasan.github.io/database_5">&lt;h1 id=&quot;숫자데이터와-관련된-함수&quot;&gt;숫자데이터와 관련된 함수&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;ABS() : 절댓값을 구하는 함수이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SIGN() : 양수면 1, 음수면 -1, 0이면 0을 리턴하는 함수이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ROUND(실수, 자릿수) : 반올림을 해 주는 함수이다. 자릿수를 음수로할 경우에는 정수부분에서 반올림,
자릿수가 양수인 경우에는 소수점에서 반올림, 0인 경우에는 소수점 첫 번째 자리에서 반올림&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TRUNC(실수, 자릿수) : 소수점 이하 자리를 버리는 함수이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CEIL(실수) : 소수점이 있을 경우 모두 버리고 실수 + 1을 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FLOOR(실수) : TRUNC와 쓰임이 비슷하다. 하지만 이 함수는 모든 소수점 자리를 버리고 정수만 출력한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;POWER(숫자, N) : 제곱된 수를 구하는 함수, N제곱된 수가 나온다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MOD(숫자, N) : 나머지를 구해주는 함수이다. 숫자를 N으로 나눈 다음, 나머지를 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;view&quot;&gt;VIEW&lt;/h1&gt;

&lt;p&gt;VIEW는물리적인 테이블에 근거한 논리적인 가상의 테이블을 말한다. 실질적으로 데이터를 저장하고 있지 않지만,
VIEW를 통해 질의하면 VIEW가 실제 테이블에 접근하여 데이터를 불러오는 방식이다.
VIEW는 필요한 내용들만 추출해서 사용하는 테이블이며, 주로 데이터를 조회할 때 가장 많이 사용되고,
테이블 처럼 사용이 가능하다. VIEW는 실제 테이블을 참조하는 가상테이블이기 떄문에 물리적인 공간이 필요없다.
테이블과 마찬가지로 INSERT, UPDATE, DELETE, SELECT와 같은 트랜젝션이 가능하다.&lt;/p&gt;

&lt;p&gt;그렇다면 VIEW를 사용하는 이유는 무엇일까?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;보완관리 : 여러 사용자들의 보안 레벨에 따라 조회할 수 있는 데이터의 범위를 조절하기 위해 사용한다.&lt;/li&gt;
  &lt;li&gt;사용자에게 편의성을 제공한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;VIEW 생성 방법 : CREATE VIEW 뷰이름 AS 쿼리문;&lt;/p&gt;

&lt;p&gt;예를 들어 CREATE VIEW EMP_HR AS SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, DEPTNO FROM EMP; 문장을 실행했다고 가정하면,
VIEW 테이블인 EMP_HR을 만들고, 이 테이블에서는 EMP 테이블의 사번, 이름, 직무, 관리자, 입사일, 부서번호만 참조 가능하게
설정하였다. 인사부의 사원이 데이터를 조회하고 싶을 때는 EMP_HR테이블을 통해 데이터를 조회할 수 있도록 설정하여
조회가능한 데이터의 범위를 조절하는 것이 가능하다.&lt;/p&gt;

&lt;p&gt;그런데 VIEW 테이블에서 INSERT, UPDATE, DELETE와 같은 데이터의 삽입, 편집이 가능하다고 했는데 VIEW는 실제데이터를
참조한 가상테이블이다. 그렇다면 데이터는 어디에 생성되는 것일까? 바로 실제테이블이다.
VIEW 테이블을 통해서 데이터를 수정하면 실제테이블에 반영이 된다. 하지만 조회목적으로 VIEW를 만들었는데 데이터의 수정이
가능하다는 말은 앞뒤가 틀리다. 따라서 VIEW 테이블을 조회가능한 테이블로만 사용할 수 있도록 키워드를 사용해주어야하는데,
그 키워드가 바로 WITH READ ONLY 이다.&lt;/p&gt;

&lt;p&gt;VIEW 테이블을 생성할 때 모든 문장을 작성하고 뒤에 WITH READ ONLY 키워드를 넣어주면 해당되는 VIEW 테이블에서는 데이터를
삽입, 수정하는 것이 불가능하고, 오직 조회만 가능하게 되는 VIEW 테이블이 된다.&lt;/p&gt;

&lt;h1 id=&quot;제약조건-부가설명&quot;&gt;제약조건 부가설명&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;NOT NULL : NULL 값이 입력되지 못하게 하는 제약조건, 특정 열에 데이터의 중복 여부와는 관계 없이 NULL 값을 허용하지 않는
제약조건을 말한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UNIQUE : 열에 저장할 데이터의 중복을 허용하지 않고자 할 때 사용하는 조건으로, NULL 값은 허용된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PRIMARY KEY : NOT NULL 제약조건과 UNIQUE 제약조건이 합쳐진 것으로, 테이블에 하나만 존재해야하는 제약조건이다.
테이블에서 PRIMARY KEY로 설정된 컬럼은 그 테이블을 대표하는 컬럼이 된다. 주민번호나 사원번호가 그 예.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FOREIGN KEY : 다른 테이블의 필드(컬럼)을 참조하여 무결성을 검사하는 조건을 말한다.
여기서 참조키는 부모 테이블의 컬럼, 외래키는 자식 테이블의 컬럼을 이야기한다.
자식 테이블의 컬럼의 값(데이터)이 부모테이블에 없는 경우에는 무결성의 규칙이 깨질 수 있다.
외래키가 존재하기 위해서는 우선적으로 부모테이블이 먼저 만들어져야 한다.
EMP 테이블의 부서번호 컬럼이 DEPT 테이블을 참조하는 외래키 컬럼이다. 어떻게 데이터가 관리되는지를 생각하자.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CHECK : 열에 저장할 수 있는 값의 범위, 또는 패턴을 정의할 때 사용하는 제약조건이다.
컬럼을 생성할 때 값을 설정할 수 있고, 설정한 값만 데이터에 입력될 수 있도록 할 때 사용되어진다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;제약조건들을 테이블을 생성할 때, 각 컬럼의 데이터값을 설정하고나서 그 뒤에 적어주면 된다.&lt;/p&gt;

&lt;p&gt;예시)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;    CREATE TABLE TEST(
        COL1 NUMBER(10) PRIMARY KEY,        -- 기본키 제약조건
        COL2 VARCHAR2(20) NOT NULL,         -- NOT NULL 제약조건
        COL3 VARCHAR2(30) NOT NULL,
        DEPTNO NUMBER(2) REFERENCES DEPT (DEPTNO)
        -- DEPTNO 컬럼이 DEPT 테이블에 있는 DEPTNO 컬럼을 참조 (DEPT가 부모테이블, TEST가 자식테이블)
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;저번 시간에 간략하게 제약조건을 배웠다. 이번시간에는 CHECK 제약조건을 처음 배웠는데 사용법을 잘 알아두어야할 것 같다.&lt;/p&gt;

&lt;p&gt;예시)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;    CREATE TABLE CHECK_TEST(
    GENDER VARCHAR2(10),
    CONSTRAINT GENDER_CH CHECK(GENDER IN ('남자', '여자'))
    -- GENDER VARCHAR2(10) CHECK(GENGER IN('남자', '여자'0)) 와 동일.
    -- CHECK 함수를 사용하여 GENDER 컬럼에는 남자 또는 여자만 올수 있도록
    -- 설정하였다. 이 경우 '남자', '여자' 데이터값 외에 다른 데이터값이 오면 에러가 발생한다.
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;시퀀스-부연설명&quot;&gt;시퀀스 부연설명&lt;/h1&gt;

&lt;p&gt;시퀀스(SEQUENCE)는 연속적인 번호를 만들어주는 기능이다. 시퀀스를 생성하기위해서는 여러 키워드를 알아야한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CREATE SEQUENCE 시퀀스이름 : 시퀀스 생성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;START WITH N : 시작번호를 설정한다. N이 시작번호가 되며, DEFAULT는 1이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;INCREMENT N : 증가할 번호를 설정한다. N이 증가번호가 되며, DEFAULT는 1이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MAXVALUE N : 시퀀스의 최댓값을 설정한다. N이 최댓값이 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MINVALUE N : 시퀀스의 최솟값을 설정한다. N이 최솟값이 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CACHE/NOCACHE : 캐시메모리를 사용할지, 안할지를 결정한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 캐시메모리의 사용여부가 꽤 중요한 개념인데, 시퀀스를 캐시메모리에 저장하는 이유는 시퀀스를 더 빨리
제공하기 위해서이다. 시퀀스 작업이 필요할 때 데이터값을 빠르게 로드할 수 있다. DEFAULT로는 20으로 설정되어있다.
하지만 캐시메모리는 휘발성메모리이기 때문에, 시스템이 비정상적으로 종료되거나 전원이 차단될 경우, 캐시메모리는
자동적으로 사라지게 되어, 시퀀스를 불러올 때 문제가 생길 수 있다. 강사님이 캐시메모리를 사용하지 않는 것을 권장하셨다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;    SELECT 시퀀스이름.NEXTVAL FROM DUAL;
    -- 시퀀스의 다음값을 불러오는 함수이다. 여기서 값이 2가 나왔을 경우 다음 값은 3이 되니 주의
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;서브쿼리중요&quot;&gt;서브쿼리(중요)&lt;/h1&gt;

&lt;p&gt;쿼리문 안에 또 다른 쿼리문을 만드는 것을 서브쿼리라고 한다.
서브쿼리는 메인쿼리가 서브쿼리를 포함하는 방식이며, 종속적인 관계로 되어있다.
여러번 쿼리를 실행해서 얻을 수 잇는 결과를 하나의 중첩된 쿼리문장으로 결과를 얻을 수 있게 해준다.&lt;/p&gt;

&lt;p&gt;서브쿼리를 사용할 때 서브쿼리는 꼭 괄호로 묶어서 사용해주어야한다.
서브쿼리 내에서 ORDER BY절은 당연히 사용할 수 없다. 결과값을 얻는 목적으로 작성하는 쿼리문이기 때문이다.
메인쿼리에서 정렬을 사용해야한다.
또한 서브쿼리는 연산자의 오른쪽에 위치해야 한다.&lt;/p&gt;

&lt;p&gt;사용방법
예시) WHERE 조건문에 이름이 SCOTT인 사람의 SAL보다 높은 SAL인 사람의 이름과 SAL을 출력하려고 할 때,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT ENAME, SAL FROM EMP WHERE SAL &amp;gt; (SELECT SAL FROM EMP WHERE ENAME = 'SCOTT');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같은 문장을 사용해주면 된다. WHERE 문에 서브쿼리를 사용하였는데, ‘이름이 SCOTT인 사원의 SAL 보다 큰 SAL을 가진 행을 출력’
하는 조건이다. 쿼리문 안에 또 다른 쿼리문이 존재하는 것이다. 다만 서브쿼리는 목적이 결과값을 얻어오는 목적으로 사용되므로
여러 데이터를 출력하는 메인쿼리와는 그 용도가 다르다.&lt;/p&gt;

&lt;p&gt;아래는 여러가지 예제를 풀어본 것이다 테이블은 EMP, DEPTNO, PRODUCTS, MEMEBER10을 토대로 예제를 풀어보았다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;    -- 1. EMP 테이블에서 평균 급여보다 더 적게 받는 사원의 사번, 이름, 담당업무, 급여, 부서번호를 화면에 출력
    SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP WHERE SAL &amp;lt; (SELECT AVG(NVL(SAL, 0)) FROM EMP);


    -- 2. EMP 테이블에서 사번이 7521인 사원과 담당업무가 같고, 급여가 7934인 사원보다 더 많이 받는 사원의 사번, 이름, 담당업무, 급여를 화면에 출력

    SELECT EMPNO, ENAME, JOB, SAL
    FROM EMP
    WHERE JOB = (SELECT JOB FROM EMP WHERE EMPNO = 7521) AND SAL &amp;gt; (SELECT SAL FROM EMP WHERE EMPNO = 7934);


    -- 3. EMP 테이블에서 담당업무가 'MANAGER'인 사원의 최소급여보다 적으면서, 담당업무가 'CLERK'는 아닌 사원의 사번, 이름, 담당업무, 급여를 화면에 출력
    SELECT EMPNO, ENAME, JOB, SAL FROM EMP WHERE SAL &amp;lt; (SELECT MIN(SAL) FROM EMP WHERE JOB = 'MANAGER') AND NOT JOB = 'CLERK';


    -- 4. 부서위치가 'DALLALS'인 사원의 사번, 이름, 부서번호, 담당업무를 화면에 출력
    SELECT E.EMPNO, E.ENAME, E.DEPTNO, E.JOB FROM EMP E JOIN DEPT D ON E.DEPTNO = D.DEPTNO WHERE D.LOC = 'DALLAS';
    SELECT EMPNO, ENAME, DEPTNO, JOB FROM EMP WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE LOC = 'DALLAS');


    -- 5. MEMBER10테이블에 있는 고객의 정보 중 마일리지가 가장 높은 회원의 모든 정보를 화면에 출력
    SELECT * FROM MEMBER10 WHERE MILEAGE = (SELECT MAX(MILEAGE) FROM MEMBER10);


    -- 6. EMP 테이블에서 'SMITH'인 사원보다 더 많은 급여를 받는 사원의 이름과, 급여를 화면에 출력
    SELECT ENAME, SAL FROM EMP WHERE SAL &amp;gt; (SELECT SAL FROM EMP WHERE ENAME = 'SMITH');


    -- 7. EMP 테이블에서 10번 부서 급여의 평균 급여보다 더 적은 급여를 받는 사원들의 이름, 급여, 부서번호를 화면에 출력
    SELECT ENAME, SAL, DEPTNO FROM EMP WHERE SAL &amp;lt; (SELECT AVG(NVL(SAL, 0)) FROM EMP WHERE DEPTNO = 10);


    -- 8. EMP 테이블에서 'BLAKE'와 같은 부서에 있는 사원들의 이름과 입사일자, 부서번호를 화면에 보여주되, 'BLAKE'는 제외하고 화면에 출력
    SELECT ENAME, HIREDATE, DEPTNO FROM EMP WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME = 'BLAKE') AND NOT ENAME = 'BLAKE';


    -- 9. EMP 테이블에서 평균급여보다 더 많은 급여를 받는 사원들의 사번, 이름, 급여를 화면에 보여주되, 급여가 높은데서 낮은 순으로 화면에 출력
    SELECT EMPNO, ENAME, SAL FROM EMP WHERE SAL &amp;gt; (SELECT AVG(NVL(SAL, 0)) FROM EMP) ORDER BY SAL DESC;


    -- 10. EMP 테이블에서 이름에 'T'를 포함하고 있는 사원들과 같은 부서에 근무하고 있는 사원의 사번과 이름, 부서번호를 화면에 출력
    SELECT EMPNO, ENAME, DEPTNO FROM EMP WHERE DEPTNO IN(SELECT DEPTNO FROM EMP WHERE ENAME LIKE '%T%');
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;group-by-having-절&quot;&gt;GROUP BY, HAVING 절&lt;/h1&gt;

&lt;p&gt;특정 컬럼이나 값을 기준으로 해당 레코드를 묶어서 자료를 관리할 떄 사용하는 키워드가 GROUP BY이다.
주로 특정 컬럼을 기준으로 집계를 구하는데 많이 사용되며, 그룹함수와 사용시 효율적으로 사용이 가능하다.&lt;/p&gt;

&lt;p&gt;예시 ) EMP 테이블의 부서 별 사원의 수를 구해볼 때,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT DEPTNO, COUNT(*) FROM EMP GROUP BY DEPTNO ORDER BY DEPTNO;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;COUNT(*)는 행의 갯수를 구하는 함수이며, GROUP BY DEPTNO를 작성하여 총 3개의 부서 별로 사원의 수가 몇 명인지를
출력해주었다. GROUP BY 키워드를 사용하지 않았다면 모든 사원 수가 출력되었을 것이다. 하나의 컬럼을 기준으로
컬럼 별로 데이터의 값들을 출력해 주는 것이 GROUP BY 절이라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;HAVING절은 GROUP BY절 다음에 나오는 조건절이다. GROUP BY 절의 결과데이터에 조건을 주어서 필터링을 할 수 있다.
GROUP BY 절에는 WHERE 절이 올 수 없으므로 HAVING절을 사용하여 필터링해주어야한다.
WHERE 절에는 그룹함수도 사용이 불가능하다는 점을 알아두자.&lt;/p&gt;

&lt;p&gt;예시 ) PRODUCTS 테이블에서 카테고리 별로 상품의 갯수를 화면에 출력하려고 할 때,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT CATEGORY_FK, COUNT(*) FROM PRODUCTS GROUP BY CATEGORY_FK HAVING COUNT(*) &amp;gt; 1 ORDER BY CATEGORY_FK;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 CATEGORY_FK는 제품의 종류, COUNT(*)는 행의 갯수를 출력하므로 제품의 갯수를 의미한다.
GROUP BY CATEGORY_FK를 사용하여 제품의 종류 별로 제품의 갯수가 몇 개인지 출력하며,
여기서 HAVING 절에 제품갯수가 1개 이상일 경우에만 출력하도록 필터링을 해주었다.
HAVING 절에는 보통 그룹함수를 많이 사용하기 때문에 이를 잘 이용하여 사용하는 것이 좋다.&lt;/p&gt;

&lt;h1 id=&quot;트랜잭션transaction&quot;&gt;트랜잭션(TRANSACTION)&lt;/h1&gt;

&lt;p&gt;트랜잭션은 데이터 처리의 한 단위를 말한다. 오라클에서 발생하는 여러 개의 SQL 명령문들을 하나의
논리적인 작업 단위로 처리하는 것을 말한다. ALL OR NOTHING 방식으로 처리하며, 명령어 여러 개의 집합이
정상적으로 처리되면 종료하고, 여러 개의 명령어 중에서 하나의 명령어라도 잘못이 되면 전체를 취소하는 방식을
말한다. 트랜잭션을 사용하는 이유로는 데이터의 일관성을 유지하면서 데이터의 안정성을 보장하기 위한 이유가 있다.&lt;/p&gt;

&lt;p&gt;트랜잭션 사용 시 트랜잭션을 제어하기 위한 명령어는 어떤 것이 있을까?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;COMMIT : 모든 작업을 정상적으로 처리하겠다고 확정하는 명령어로, INSERT, DELETE, UPDATE와 같은 작업의 내용을
실제 DB에 반영하고, 이전에 있던 데이터에 UPDATE 현상을 발생시킨다.
모든 사용자가 변경된 데이터의 결과를 확인할 수 가 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ROLLBACK : 작업 중에 문제가 발생했을 때, 트랜잭션 처리 과정에서 발생한 변경 사항을 취소하여 이전 상태로
되돌리는 명령여이다. 트랜잭션 작업 내용을 취소하는 것이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;COMMIT의 경우에는 사진을 찍는 것과 같다. COMMIT 명령어를 실행하면, 실행할 상태의 모든 데이터들을 그 상태 그대로
저장하는 것을 말한다. 그 이후에 데이터를 관리하다가 문제가 발생했을 때 ROLLBACK 명령어를 사용하면 COMMIT을 했던 그 상태로
타임머신을 타고 이동하는 것과 같다.&lt;/p&gt;

&lt;p&gt;COMMIT은 DB의 전체적인 상태들을 저장하기 때문에 사소한 데이터 수정을 위해서 커밋을 하는 것은 부담스러울 수 있다.
이를 보완하고자 SAVEPOINT라는 키워드가 있는데, 단어 뜻 그대로 세이브포인트를 세워서 문제가 발생했을 경우 세이브포인트 지점으로
돌아갈 수 있다.&lt;/p&gt;

&lt;p&gt;SAVEPOINT 이름; 으로 사용할 수 있으며, 만들었던 세이브포인트로 돌아가기 위해서는 ROLLBACK 이름; 을 입력하여 돌아갈 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;제약-조건-책-보면서-추가-공부&quot;&gt;제약 조건 책 보면서 추가 공부&lt;/h1&gt;

&lt;p&gt;제약조건을 추가할 때 제약조건에 이름을 붙여줄 수 있다. 제약조건에 이름을 붙여주지 않으면 ORACLE DB에서 자체적으로 이름을 부여하는데,
찾을 때 복잡하고 찾기가 힘들다는 이야기가 있다. 제약조건에 이름을 붙여주면 나중에 제약조건의 내용을 수정할 때 쓸 수 있으므로
제약조건에 이름을 넣어주는 것이 좋다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE TEST_TABLE(
    NUM NUMBER(20)
    CONSTRAINT TEST_TABLE_PK PRIMARY KEY,
    NAME VARCHAR2(20)
    CONSTRAINT TEST_TABLE_nn NOT NULL,
    PHONE VARCHAR2(50)
    CONSTRAINT TEST_TABLE_PHONE NOT NULL
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같은 형식으로 제약조건을 넣어준다.&lt;/p&gt;

&lt;p&gt;테이블 생성 시에는 제약조건의 필요성을 느끼지 못했다가, 나중에 제약조건을 추가해야할 상황이 생겼을 때, 제약조건의 이름을 찾아 조건을 변경하거나
추가할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE TEST_TABLE ADD CONSTRAINT TEST_TABLE_UNIQUE UNIQUE(NAME);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;기존에 있는 제약이름은 사용할 수 없다. 새로운 이름을 생성하고 거기에 ‘제약조건(컬럼)’ 형식으로 써주어야한다.&lt;/p&gt;

&lt;p&gt;유의해야할 사항이 하나 더 있는데, NOT NULL 제약조건을 넣을 때이다. 컬럼에 기본값으로 NULL이 허용되있는 것을 변경하는 것이기 때문에
이 때는 ADD를 사용하면 안되고, MODIFY() 함수를 사용해서 수정해주어야한다.&lt;/p&gt;

&lt;p&gt;외래키 제약조건은 자식테이블이 부모테이블을 참조하는 형식이다. 만약, 자식테이블의 데이터가 있다면 부모테이블을
참조하고 있기 때문에 부모테이블의 데이터를 삭제할 수 없다. 따라서 이를 해결하기위한 키워드가 존재한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ON DELETE CASCADE : 부모테이블의 데이터를 지울 때 자식테이블의 데이터(행 전체)도 같이 지운다.&lt;/li&gt;
  &lt;li&gt;ON DELETE SET NULL : 부모테이블의 데이터를 지우면 자식테이블의 데이터는 NULL 값이 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두 키워드는 차이점을 가지고 있는데, ON DELETE CASCADE같은 경우에는 부모테이블의 데이터를 삭제하면
자식테이블의 데이터 행 자체가 삭제된다는 점이다. 반면 ON DELETE SET NULL 같은 경우에는 자식테이블이 참조하던
컬럼의 데이터만 NULL 값으로 표시되고, 행 자체의 데이터는 사라지지 않는다.
이 키워드는 제약조건에 FOREIGN KEY를 설정할 때 문장의 마지막에 작성해주면 된다.&lt;/p&gt;

&lt;h1 id=&quot;서브쿼리-책-보면서-복습-정리&quot;&gt;서브쿼리 책 보면서 복습, 정리&lt;/h1&gt;

&lt;p&gt;수업시간에 배운 내용은 책을 보면서 복습이 얼추 되었다. 근데 책에서는 다중쿼리에 대해 비중있게 다루고 있는데,
먼저 다중행 서브쿼리이다. 다중행 서브쿼리는 서브쿼리에서 나오는 결과값이 여러 개인 경우가 있는데, 이를 다중 쿼리라고 부르는데,&lt;/p&gt;

&lt;p&gt;수업시간에는 IN만 사용하여 다중쿼리의 데이터 값을 처리했지만, 연산자가 몇 가지 더 존재했다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;EXISTS : 서브쿼리의 값이 있을 경우에 메인쿼리를 수행&lt;/li&gt;
  &lt;li&gt;&amp;gt; ANY(서브쿼리) : 서브쿼리 결과중에서 최솟값을 반환&lt;/li&gt;
  &lt;li&gt;&amp;lt; ANY(서브쿼리) : 서브쿼리 결과중에서 최댓값을 반환&lt;/li&gt;
  &lt;li&gt;&amp;lt; ALL(서브쿼리) : 서브쿼리 결과중에서 최솟값을 반환&lt;/li&gt;
  &lt;li&gt;&amp;gt; ALL(서브쿼리) : 서브쿼리 결과중에서 최댓값을 반환&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;구별을 잘 해야한다. 비교하고싶은 데이터 값보다 작은지, 큰지를 먼저 따지고, 그 다음에 서브쿼리의 데이터 값 중
최솟값, 최댓값을 가져오는 것을 잘 설정해주어야 한다.&lt;/p&gt;

&lt;h2 id=&quot;다중컬럼&quot;&gt;다중컬럼&lt;/h2&gt;

&lt;p&gt;다중행은 서브쿼리가 여러개의 결과값을 가진 것이었다. 다중컬럼은 결과값이 여러 컬럼을 가지는 것을 말한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT P.PROFNO, P.NAME, P.HIREDATE, D.DNAME
FROM PROFESSOR P
JOIN DEPARTMENT D
ON P.DEPTNO = D.DEPTNO
WHERE (P.DEPTNO, P.HIREDATE) IN(SELECT DEPTNO, MIN(HIREDATE) FROM PROFESSOR GROUP BY DEPTNO);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;WHERE 절에 쓰인 문장을 보자, 서브쿼리에서 메인쿼리로 컬럼이 2개씩 데이터로 받아지고 있다.
각 부서별로 입사일이 가장 오래된 교수를 서브쿼리에서 결과값으로 추출한 후, 메인쿼리로 옮겨서
조건에 맞는 행을 출력하는 것이다. 다양한 검색을 할 때 사용되므로 이해해야한다.&lt;/p&gt;

&lt;h2 id=&quot;스칼라-서브쿼리scalar-sub-query&quot;&gt;스칼라 서브쿼리(Scalar Sub Query)&lt;/h2&gt;

&lt;p&gt;스칼라 서브쿼리는 SELECT 절에 오는 서브쿼리로 한 번에 결과를 1행씩 반환한다.
실무에서 많이 사용되고 SQL 튜닝에서도 강조되는 부분이다.&lt;/p&gt;

&lt;p&gt;스칼라 서브쿼리는 OUTER JOIN과 구조가 비슷하다.
JOIN방법은 출력하고자 하는 데이터의 양이 적을 경우 스칼라 서브 쿼리보다 속도가 느리다. 따라서
출력하는 데이터의 양이 적을 경우에는 JOIN보다 스칼라 서브 쿼리를 많이 사용한다.
데이터의 양이 많을 경우에는 JOIN이 더 효율적일 수 있으니 잘 판단하여 사용하여야 한다.
스칼라 서브 쿼리가 빠른 이유는 찾는 데이터가 메모리에 만들여져 있는 값을 찾아오기 때문이다.&lt;/p&gt;

&lt;p&gt;메모리에 미리 찾을 것으로 예상되는 조건으로 데이터를 준비하고, 주문이 들어오면 바로 찾아가는 것이다.
시쿼스에서 봤었던 캐시메모리와 비슷한 상황인 것 같다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Achasan</name>
        
        
      </author>

      

      
        <category term="Basic" />
      

      
        <summary type="html">숫자데이터와 관련된 함수</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">그룹함수(GROUP BY, HAVING)</title>
      <link href="https://achasan.github.io/database_4" rel="alternate" type="text/html" title="그룹함수(GROUP BY, HAVING)" />
      <published>2021-09-05T00:00:00+09:00</published>
      <updated>2021-09-05T00:00:00+09:00</updated>
      <id>https://achasan.github.io/database_4</id>
      <content type="html" xml:base="https://achasan.github.io/database_4">&lt;h1 id=&quot;sql-복수행-함수그룹함수&quot;&gt;SQL 복수행 함수(그룹함수)&lt;/h1&gt;

&lt;p&gt;단일행 함수는 하나의 데이터가 가공되는 방식이었다면, 복수행함수는 한꺼번에 여러 건의 데이터가 함수로 입력되는
방식이다. 사용법은 일반적인 함수와 매우 비슷하다. 다만 주의해야할 점은 null값을 각 함수마다 어떻게 취급하는지를
알아야 한다는 점이다. 주로 사용되는 복수행 함수들을 알아보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;COUNT() : 입력되는 데이터의 갯수를 출력한다.&lt;/li&gt;
  &lt;li&gt;SUM() : 입력된 데이터의 합계 값을 출력한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AVG() : 입력된 데이터의 평균값을 출력한다. NULL 값은 제외하기 때문에 NVL()함수로 치환하는 것이 좋다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;MAX() : 입력된 데이터 중 가장 큰 값을 출력한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MIN() : 입력된 데이터 중 가장 작은 값을 출력한다.
※ MAX() 함수와 MIN() 함수는 정렬한 후에 가장 큰 값/작은 값을 출력하기 때문에 성능이 좋지 않다.
추후에 INDEX를 사용하는 것을 추천한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;STDDEV() : 입력된 값중 표준편차를 출력한다.&lt;/li&gt;
  &lt;li&gt;VARIANCE() : 입력된 값 중 분산값을 출력한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;group-by--특정-조건으로-세부적인-그룹화하기&quot;&gt;GROUP BY : 특정 조건으로 세부적인 그룹화하기&lt;/h2&gt;

&lt;p&gt;EMP 테이블에서 SAL 컬럼의 평균을 구한다고 해보자. SAL의 평균은 단순히 컬럼에 있는 SAL 데이터 값들을
평균으로 나누기 때문에 하나의 데이터만 출력될 것이다.
하지만 직업별로 SAL 평균을 보고싶을 때는 어떻게 해야할까?&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT JOB, TRUNC(AVG(NVL(SAL, 0)), 0) FROM EMP GROUP BY JOB;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음의 문장을 작성하면 직업별로 급여평균을 출력할 수 있다. 뒤에 GROUP BY 키워드가 보이는데, 이는 JOB의
데이터를 그루핑하여 출력하라는 의미가 된다. 따라서 직업 별로 SAL의 평균값이 출력되게 된다.&lt;/p&gt;

&lt;p&gt;조금 더 응용해보자,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT JOB, TRUNC(AVG(NVL(SAL, 0)), 0)
FROM EMP
GROUP BY DEPTNO, JOB;`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이번엔 GROUP BY가 두 번 사용되었다. 먼저 부서별로 그룹핑한 다음, 부서 별로 존재하는 각 직업 별로 두 번 그룹핑하여
데이터를 출력하라는 의미이다.
예를 들어, 부서번호가 10, 20, 30으로 3개가 있고, 직업이 5개가 있다고 할 때, 부서번호가 10인 그룹의 직업 별 평균,
20인 그룹의 직업 별 평균, 30인 그룹의 직업 별 평균을 출력하라는 뜻이 된다.
다소 헷갈릴 수 있으니 제대로 이해하고 넘어가야 한다.
그룹핑을 했을 경우에는 데이터가 정렬이 안되게 뒤죽박죽 섞여있으므로 ORDER BY를 통해 정렬해 주는 것이 보기 좋다.&lt;/p&gt;

&lt;p&gt;GROUP BY를 사용하기 위해서는 두 가지의 조건이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;SELECT 절에 사용된 컬럼이나 포현식은 반드시 GROUP BY 절에 사용되어야 한다. 안그러면 에러가 난다.
(GROUP BY에 사용된 컬럼은 SELECT에 반드시 있어야할 필요는 없다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GROUP BY절에는 반드시 컬럼명이 사용되어야 하고, 컬럼 별칭은 사용될 수 없다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;having-절의-사용&quot;&gt;HAVING 절의 사용&lt;/h2&gt;

&lt;p&gt;WHERE 문에 그룹함수를 사용하여 조건식을 작성할 수 있을까? 답은 NO다. WHERE문에서는 그룹 함수를
비교조건으로 사용할 수 없다. 대신 HAVING문을 사용하면 해결이 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT DEPTNO, AVG(NVL(SAL,0)) -- 부서번호, 급여평균 출력
FROM EMP -- EMP 테이블에서
WHERE DEPTNO &amp;gt; 10 -- DEPTNO가 20, 30인 경우
GROUP BY DEPTNO -- 부서번호 별로 평균 출력
HAVING AVG(NVL(SAL, 0)) &amp;gt; 2000; -- 급여평균이 2000 이상인 경우 출력(그룹함수는 HAVING문으로 조건을 줄 수 있다.)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;WHERE문에 그룹함수를 사용할 수 없다는 사실이 중요하다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Achasan</name>
        
        
      </author>

      

      
        <category term="Basic" />
      

      
        <summary type="html">SQL 복수행 함수(그룹함수)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">묵시적, 명시적 형변환, DECODE, 정규식</title>
      <link href="https://achasan.github.io/database_3" rel="alternate" type="text/html" title="묵시적, 명시적 형변환, DECODE, 정규식" />
      <published>2021-09-04T00:00:00+09:00</published>
      <updated>2021-09-04T00:00:00+09:00</updated>
      <id>https://achasan.github.io/database_3</id>
      <content type="html" xml:base="https://achasan.github.io/database_3">&lt;h1 id=&quot;묵시적-형변환-명시적-형변환&quot;&gt;묵시적 형변환, 명시적 형변환&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;묵시적 형변환&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;묵시적 형변환은 말그대로 개발자가 따로 형변환을 지시하지 않아도 시스템에서 자동적으로 형변환을 일어나게 하는 것을 말한다. 자바에서는 “1” + 1 을 출력하면 “11”이 되어 문자로 묵시적형변환이 일어나지만 SQL에서는 ‘1’ + 1 을 하면 2가 출력된다. 문자가 숫자로 변환되는 형변환이 일어난다. 문자는 숫자 형태로 되어있어야 형변환이 일어난다. 1 + ‘A’가 산술계산이 안되는 것 과 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;명시적 형변환&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;명시적 형변환은 함수를 사용하여 데이터값의 자료형을 다른 타입으로 바꾸는 것을 말한다. 형변환을 할 수 있는 함수는 총 3가지가 존재한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[날짜 &amp;gt; 문자] TO_CHAR(DATE, ‘FORMAT’) : 날짜를 문자로 변환시킬 때 사용, 매개값으로는 날짜 데이터, 출력 형식을 작성하면 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;출력형식 : 다양한 출력형식을 제공하고 있는데 대표적인 것들만 추려보면&lt;/li&gt;
  &lt;li&gt;년 : YYYY(2021), YY(21), YEAR(TWENTY TWENTY-ONE)&lt;/li&gt;
  &lt;li&gt;월 : MM(09), MONTH(SEPTEMBER)&lt;/li&gt;
  &lt;li&gt;일 : DD(04), DDTH(4TH - 몇 번째 날인지를 표시)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;시간 : HH24(하루를 24시간으로 표시) / HH(하루를 12시간으로 표시), MI(분), SS(초)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[숫자 &amp;gt; 문자] TO_CHAR(NUMBER, ‘FORMAT’) : 숫자를 문자형으로 변환시키는 함수이다. 역시 형식을 지정하여 변환시킬 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;출력 형식&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;9 : 자릿수를 뜻한다. TO_CHAR(1234, ‘99999’)는 1234를 5자리까지만 출력하라는 의미인데, 1234는 4자리이므로 남은 자릿수는 출력되지않음&lt;/li&gt;
  &lt;li&gt;0 : 빈 자릿수를 0으로 채운다는 뜻이다. TO_CHAR(1234, ‘099999’)를 실행하면 001234가 나오게 된다.&lt;/li&gt;
  &lt;li&gt;$ : $를 붙여서 표시한다는 뜻, TO_CHAR(1234, ‘$9999’)를 실행하면 $1234가 나온다.&lt;/li&gt;
  &lt;li&gt;. : 소수점 이하를 표시한다. 소수가 없더라도 0으로 표시된다. TO_CHAR(1234, ‘9999.00’) = 1234.00&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;, : 천 단위 구분 기호를 표시한다. TO_CHAR(1234, ‘99,999’) = 1,234&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;TO_NUMBER() : 숫자 형태로 생긴 문자를 숫자로 바꿔주는 함수이다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TO_NUMBER(‘2’) = 2로 출력된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;TO_DATE() : 날짜 형태로 생긴 문자를 DATE 타입으로 바꿔주는 함수이다.&lt;/li&gt;
  &lt;li&gt;TO_DATE(‘2021/09/04’) = 2021년 9월 4일의 DATE 타입으로 바뀐다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;decode--오라클-db의-if문&quot;&gt;DECODE() : 오라클 DB의 IF문&lt;/h1&gt;

&lt;p&gt;DECODE()는 오라클 문법에 있는 IF문이라고 생각하면 된다.
서로의 데이터가 같은지, 다른지를 구별하여 같을 경우, 다를 경우에 출력하는 값을 다르게 설정 가능하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DECODE(A, B, ‘1’, null) : A = B일 경우 ‘1’, A != B일 경우 NULL 출력&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DECODE(A, B, ‘1’, C, ‘2’, null) : A = B 면 ‘1’, A = C 면 ‘2’, 해당하지 않을 경우 NULL 출력
무조건 기준은 첫 번째 매개값이라는 것을 알 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;DECODE(A, B, DECODE(C, D, ‘, NULL)) : 안쪽에 있는 DECODE부터 실행된다. C = D이면 ‘, C != D이면 NULL 출력 후&lt;/li&gt;
  &lt;li&gt;A = B 이면 DECODE() 값, A != B 이면 DECODE 값 출력
ELSE에 해당하는 네 번째 매개값이 비어있으면 아무것도 출력하지 않은 상태가 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;case문&quot;&gt;CASE문&lt;/h1&gt;

&lt;p&gt;DECODE가 데이터 값들의 ‘=’ 연산자만들 사용하여 처리되는 함수라면, CASE는 크거나 작은 조건까지 처리가 가능하다.
CASE 문은 CASE() WHEN THEN ELSE END 순으로 사용이 된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CASE(조건) WHEN(결과값 기준 조건문) THEN(출력값)
           WHEN(결과값 기준 조건문2) THEN(출력값2)
           WHEN(결과값 기준 조건문3) THEN(출력값3)
           WHEN(결과값 기준 조건문4) THEN(출력값4)
           ELSE (출력값5)
           END (별칭)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;CASE : CASE 뒤에는 함수나 연산을 통해 만들어져 나올 테이터 값을 적으면 된다.&lt;/li&gt;
  &lt;li&gt;WHEN : CASE를 통해서 나온 결과값을 판단할 조건문을 작성해주면 된다. WHERE문처럼 사용한다.&lt;/li&gt;
  &lt;li&gt;THEN : 조건에 일치할 경우에 출력할 값 적는다.&lt;/li&gt;
  &lt;li&gt;ELSE : 여러가지 WHEN, THEN을 통해서 작성한 조건에 모두 일치하지 않을 경우 출력할 값을 적는다.&lt;/li&gt;
  &lt;li&gt;END : CASE문을 통해 출력될 값들의 컬럼 별칭을 적는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CASE 문에서는 컴마가 사용되지 않는다. 또한 연동하여 사용되는 키워드가 많으므로 잘 이해하고 사용해야한다.
물론 그렇다고 CASE문만 사용하는 것은 아니다. ‘=’을 통한 조건식을 사용하는 경우에는 DECODE 문이 훨씬 효율적이다.
따라서 적절히 상황에 맞추어 사용하는 것이 좋다.&lt;/p&gt;

&lt;h1 id=&quot;정규식-내용-정리&quot;&gt;정규식 내용 정리&lt;/h1&gt;

&lt;p&gt;이전에 LIKE 키워드를 사용하여 %과 _를 통해 원하는 위치에 오는 문자열을 찾는 조건문을 작성한 적이 있는데,
이를 보다 구체적으로 체계화한 것이 정규식이다. 정규식은 유닉스에서 검색할 때 주로 사용되는 기술로 다양한
메타문자들을 사용하여 검색 방법을 확장하는 것을 말한다. 먼저 정규식과 관련된 함수부터 알아보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;REGEXP_LIKE : LIKE 함수처럼 특정 패턴과 매칭되는 결과를 검색해내는 함수이다.&lt;/li&gt;
  &lt;li&gt;REGEXP_REPLACE : REPLACE 함수를 확장한 개념으로 주어진 문자열에서 특정 패턴을 찾아서 주어진 다른모양으로 치환하는 함수&lt;/li&gt;
  &lt;li&gt;REGEXP_SUBSTR : SUBSTR 함수를 확장하여 특정 패턴에서 주어진 문자를 추출해 내는 함수&lt;/li&gt;
  &lt;li&gt;REGEXP_COUNT : 특정 메타문자를 사용하여 정규식에 해당하는 문자의 갯수를 카운트해주는 함수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정규식 함수를 사용하기 위해서는 메타문자라는 것을 알아야한다. 메타문자는 상당히 복잡하고 외워야할 것도 많다.
주로 사용하는 메타문자들을 알아보자&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;^ : 해당 문자로 시작하는 데이터를 출력&lt;/li&gt;
  &lt;li&gt;$ : 해당 문자로 끝나는 데이터 출력&lt;/li&gt;
  &lt;li&gt;. : 자릿수를 의미한다 EX ) ‘S…E’ S로 시작하여 중간에 3자릿수가 있고 E로 끝나는 데이터&lt;/li&gt;
  &lt;li&gt;[] : 해당 문자에 해당하는 문자열&lt;/li&gt;
  &lt;li&gt;[^] : 해당 문자에 해당하지 않는 문자열&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;정규식-이해해보기&quot;&gt;정규식 이해해보기&lt;/h3&gt;

&lt;p&gt;예를 들어 REGEXP_LIKE(TEXT, ‘[A]’) 는 TEXT 컬럼에서 ‘A’를 포함하는 문자를 모두 출력하라는 뜻을 가지고 있다.
REGEXP_LIKE 는 WHERE 문 뒤에 사용하며, 정규식으로 사용된 ‘[A]’는 []가 해당 문자에 해당하는 문자열을 출력하라는
의미를 가지고 있으므로 ‘A’가 포함된 문자를 출력하라는 뜻이 된다.&lt;/p&gt;

&lt;p&gt;조금 더 응용하자면 ‘[A-Z]’는 알파벳 대문자를 포함하는 데이터를 출력하라는 뜻이 되고,
‘[a-zA-Z]’는 모든 알파벳이 포함되어있다면 데이터를 출력하라는 의미가 된다.&lt;/p&gt;

&lt;p&gt;그렇다면 ‘[A-Z] ‘ 의 뜻은 무엇일까? 알파벳 대문자로 시작하고(AND) 뒤에 공백이 있는 데이터를 출력하라는 의미가 된다.
‘[A-Z] [0-9]’ 는 알파벳 대문자로 시작, 뒤에 공백이 있고 바로 다음에 숫자중 하나가 오는 정규식을 포함하는 데이터를
출력하라는 의미가 된다.&lt;/p&gt;

&lt;h3 id=&quot;연속적인-글자-수-지정하기--&quot;&gt;연속적인 글자 수 지정하기 : {}&lt;/h3&gt;

&lt;p&gt;‘[A-Z]{2}’의 뜻은 무엇일까? 알파벳 대문자가 연속적으로 2개 오는 데이터를 포함하면 출력하라는 뜻이다.
중괄호 안에 숫자가 들어가면 앞에 작성한 정규식이 연속으로 몇개 포함되어야하는지를 정할 수 있다.&lt;/p&gt;

&lt;p&gt;응용해보자, ‘[A-Z][0-9]{3}’이 나온다면 무슨 뜻이 될까? 알파벳 대문자와 숫자가 연속으로 오는 3자리의 데이터가 있다면
출력하라는 뜻을 가지고 있다. 유의해야할 점은 알파벳대문자가 먼저쓰였으므로, 숫자가 먼저나오고 알파벳 대문자가 나오는
데이터는 포함되지 않는다. 세 자릿수라고 써저있는 부분은 알파벳 대문자가 맨 앞에 나오고, 뒤의 두 자리 중에 숫자가 하나만
오면 된다.&lt;/p&gt;

&lt;h3 id=&quot;특정-위치를-지정하여-출력---&quot;&gt;특정 위치를 지정하여 출력 : ^, $&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'^[a-zA-Z]'&lt;/code&gt;의 정규식을 이해해보자. ^는 위에서 시작되는 문자를 지정할 때 쓰인다고 했었다.
알파벳 소문자나 대문자로 시작하는 데이터를 출력하라는 뜻이 된다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'^[0-9A-Z]'&lt;/code&gt;의 정규식은 숫자로 시작하거나 알파벳 대문자로 시작하는 데이터를 출력하라는 의미가 된다.&lt;/p&gt;

&lt;p&gt;여기서 한 가지 팁이 있는데, 여러 정규식을 연결할 때 바&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(|)&lt;/code&gt;를 사용하여 연결할 수 있다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'^[A-Z]|^[0-9]'&lt;/code&gt;의 정규식은 알파벳 대문자로 시작하거나 숫자로 시작하는 데이터를 출력하라는 뜻이 된다.&lt;/p&gt;

&lt;p&gt;대괄호 밖에 ^를 사용하면 시작위치를 정하는 의미가 된다. 대괄호 안에 ^를 넣으면 반대의 의미가 된다.
NOT의 의미를 가지는 셈인데, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'[^a-z]'&lt;/code&gt;를 정규식으로 사용한다면, 알파벳 대문자로 이루어지지않은 데이터를 출력하라는 뜻이 된다.&lt;/p&gt;

&lt;p&gt;지금까지 배운 내용들을 응용하여 전화번호의 지역번호 중 서울만 출력하도록 필터링하기로 해보자.,
서울은 02로 시작하고, 나머지 지역은 3자리로 시작하는 지역번호를 가지고 있다.
이를 정규식으로 나타내면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'^[0-9]{2}\)[0-9]{4}'&lt;/code&gt;으로 나타낼 수 있다. ‘)’ 부분은 지역번호 뒤에 ‘)’가 붙어서 써준건데,
‘)’를 그냥 쓰게되면 함수의 소괄호가 종료되는 것으로 인식될 수 있다. 따라서 ‘)’ 앞에 역슬래시()를 붙여주어 정규식에 사용하는
소괄호라는 것을 시스템에 인식하도록 해준다. 이를 탈줄자(ESCAPE CASE)라고 한다. 탈출자는 후에 설명한다.&lt;/p&gt;

&lt;h3 id=&quot;특정-조건-제외한-결과를-출력&quot;&gt;특정 조건 제외한 결과를 출력&lt;/h3&gt;

&lt;p&gt;NOT을 사용하면 특정 조건을 제외한 결과를 출력하게 된다. 이전에 WHERE 문에서 NOT을 사용하면 조건식을 제외한 모든
데이터들이 출력된다 했었는데 그와 같은 것이다.&lt;/p&gt;

&lt;h3 id=&quot;특수문자를-찾기&quot;&gt;특수문자를 찾기&lt;/h3&gt;

&lt;p&gt;데이터값 중에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_&lt;/code&gt;이나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?&lt;/code&gt;같은 특수문자도 들어가있기 마련이다. 하지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_&lt;/code&gt;같은 경우에는 모든 값을 출력하는
키워드인데, 이를 어떻게 해야 문제없이 문자로 인식하게 할 수 있을까?
원래 기호의 뜻이 아닌 다른 뜻을 가진 문자를 메타문자라고 하는데, 메타문자로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?, *&lt;/code&gt; 등이 있다.
이러한 메타문자를 문자데이터값 그대로 출력하기 위해서는 ‘'를 사용하여야한다. 메타문자 앞에 역슬래시를 붙이면
문자데이터값 그대로 출력할 수 있다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Achasan</name>
        
        
      </author>

      

      
        <category term="Basic" />
      

      
        <summary type="html">묵시적 형변환, 명시적 형변환</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">조건절 키워드(LIKE, ORDER BY, NOT), 시퀀스, JOIN, DUAL 테이블</title>
      <link href="https://achasan.github.io/database_2" rel="alternate" type="text/html" title="조건절 키워드(LIKE, ORDER BY, NOT), 시퀀스, JOIN, DUAL 테이블" />
      <published>2021-09-03T00:00:00+09:00</published>
      <updated>2021-09-03T00:00:00+09:00</updated>
      <id>https://achasan.github.io/database_2</id>
      <content type="html" xml:base="https://achasan.github.io/database_2">&lt;h1 id=&quot;오라클db-공부-20210903&quot;&gt;오라클DB 공부 20210903&lt;/h1&gt;

&lt;h2 id=&quot;like--특정패턴을-가지고-있는-조건을-검색&quot;&gt;LIKE : 특정패턴을 가지고 있는 조건을 검색&lt;/h2&gt;

&lt;p&gt;LIKE는 WHERE 조건절 뒤에 오는 연산자로, 특정패턴을 가진 데이터를 검색하는 기능을 가지고 있다.&lt;/p&gt;

&lt;p&gt;특정 패턴을 설정하는 방법은 ‘%’와 ‘_‘로 설정할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;% : 글자 수, 문자 제한이 없다. 무엇이든 와도 상관없다는 뜻으로 생각하면 편하다.&lt;/li&gt;
  &lt;li&gt;_ : 글자수에 제한을 두고, 어떤 문자가 와도 상관이 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;EX) WHERE ENAME LIKE ‘%S’ : 이름이 S로 끝나는 데이터를 찾는다. 앞 문자는 어떤 문자가 와도 상관없다.
WHERE ENAME LIKE ‘__S%’ : 세 번째 글자가 S인 데이터를 찾는다, 첫 번째, 두 번째 문자와 뒷 문자는 어떤 문자가 와도 상관없다.&lt;/p&gt;

&lt;h2 id=&quot;order-by--자료-정렬시-사용&quot;&gt;ORDER BY : 자료 정렬시 사용&lt;/h2&gt;

&lt;p&gt;SELECT 문장의 맨 마지막에 오는 키워드로, ASC를 입력하면 오름차순, DESC를 입력하면 내림차순으로 정렬하도록 할 수 있다.&lt;/p&gt;

&lt;p&gt;AEC의 경우에는 생략이 가능하다.
NULL값의 경우 오름차순에서는 제일 나중에 나오고, 내림차순일 경우에는 제일 먼저 나온다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT \* FROM MEMBER10 ORDERBY MEMNAME ASC, AGE DESC;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;MEMBER10 테이블의 이름을 오름차순으로 정렬한다. 만약 이름이 중복된다면 나이를 내림차순으로 정렬한다.
ORDER BY에는 여러 개의 컬럼을 정렬할 수 있는데, 맨 앞의 컬럼부터 정렬순위가 정해지는 방식이다.&lt;/p&gt;

&lt;h2 id=&quot;not--부정의-의미를-가진-키워드&quot;&gt;NOT : 부정의 의미를 가진 키워드&lt;/h2&gt;

&lt;p&gt;긍정의 쿼리문을 작성 후 NOT을 넣어주어 사용한다. NOT은 관게연산자의 앞에 붙여주며,
비교연산자를 사용하는 겨웅에는 WHERE 뒤에 붙여준다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EX) WHERE ADDR NOT LIKE '경기도%';      경기도로 시작하지 않는 주소를 불러오도록 한다.
    WHERE NOT OUTPUT_PRICE &amp;lt; 1000000;   출고가가 1000000원 이상인 데이터를 불러온다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;주로-사용하는-그룹함수&quot;&gt;주로 사용하는 그룹함수&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;AVG() : 평균값을 구해주는 함수, 매개값으로 컬럼을 넣어줄 수 있다.&lt;/li&gt;
  &lt;li&gt;COUNT() : 행의 갯수를 구해주는 함수이다. NULL은 COUNT에 포함되지 않는다.&lt;/li&gt;
  &lt;li&gt;MAX() : 컬럼의 값들 중 최댓값을 구해주는 함수이다.&lt;/li&gt;
  &lt;li&gt;MIN() : 컬럼의 값들 중 최솟값을 구해주는 함수이다.&lt;/li&gt;
  &lt;li&gt;SUM() : 컬럼들의 데이터 값들을 합한 값을 구해주는 함수이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;시퀀스sequence&quot;&gt;시퀀스(SEQUENCE)&lt;/h1&gt;

&lt;p&gt;오라클에서는 자동순번을 부여하는 기능이 없는데, 대신 시퀀스를 사용할 수 있다.
시퀀스는 순번을 정할 때 사용하는 문법을 말한다. 시퀀스를 사용하는 이유는 스레드와 관련이 있는데,
A, B, C, D 라는 유저가 게시물을 작성하고 있다. 왼쪽부터 먼저 들어온 순서대로 게시물을 작성하였으나,
게시글을 업로드한 순서는 C, B, A, D 순서가 되었다. 이 경우, 게시물 순번은 업로드가 먼저 이루어진 C부터 순번이 부여되어야 한다.
따라서 순번을 업로드 된 순서대로 부여하기 위해 시퀀스를 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;시퀀스-생성&quot;&gt;시퀀스 생성&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE SEQUENCE (시퀀스이름) START WITH (시작 수) INCREMENT BY (증가할 수);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;시퀀스를 생성하기 위해서는 시퀀스 이름을 생성하고, 시퀀스의 시작하는 수와, 몇 씩 수를 증가시킬 지를 정해서 생성할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;cache_size&quot;&gt;CACHE_SIZE&lt;/h2&gt;

&lt;p&gt;시퀀스를 생성하면 시퀀스 정보에 CACHE_SIZE 항목을 볼 수 있다. 기본값은 20으로 설정되어있는데, 20의 용량만큼 데이터를 임시저장하여
사용한다는 뜻이다. 캐시메모리는 휘발성 메모리로, 만약 서버(컴퓨터)가 갑자기 꺼지는 상황이 발생하면 캐시메모리에 저장되어있던
20의 용량에 있던 값들은 사라지게 된다. 순번20번 까지를 캐시메모리에 미리 저장해놓은 상태에서 게시글이 10개가 작성되어 순번이 10까지 부여되어 DB에 저장되어있었는데, 컴퓨터가 꺼진다면
다시 서버를 동작시켰을 때 시퀀스는 21부터시작하게 된다. 이러한 문제가 발생할 수 있기 때문에 캐시메모리는 안 사용하는 것을 권장한다.&lt;/p&gt;

&lt;h3 id=&quot;시퀀스이름nextval--시퀀스의-다음-번호를-부여하는-문법&quot;&gt;시퀀스이름.NEXTVAL : 시퀀스의 다음 번호를 부여하는 문법&lt;/h3&gt;

&lt;h2 id=&quot;join--on&quot;&gt;JOIN ~ ON&lt;/h2&gt;

&lt;p&gt;테이블과 테이블을 결합한, 특정데이터를 불러오고 싶을 떄 사용하는 키워드이다.
JOIN의 종류에는 4가지 종류가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;CROSS JOIN : 2개 이상의 테이블이 조인되었을 때 조건없이 모두 결합된다. 테이블의 전체 행과 컬럼이 조인되기 때문에 중복값이 많아진다.&lt;/p&gt;

    &lt;p&gt;SELECT * FROM EMP, DEPT;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;단순히 EMP와 DEPT의 테이블을 합친 데이터들이 출력된다. 조건없이 결합되기 때문에 중복값이 많아져 효율적인 데이터이지 못하다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;EQUI JOIN : 조인이 대상이 되는 두 테이블에서 공통으로 존재하는 컬럼을 연결하여 결과를 생성하는 방법이다.
공통되는 컬럼은 컬럼이름이 일치할 수 있기 때문에 따로 별칭을 설정하여 구분해 주는 것이 좋다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;EX) EMP테이블에서 사원의 사번, 이름, 담당업무, 부서번호, 부서명, 근무 위치를 출력해야할 때, EMP 테이블에는 부서명, 근무위치가 없어서 DEPT 테이블에서 가져와야하는 상황이 생긴다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT E.EMPNO, E.ENAME, E.JOB, E.DEPTNO, D.DNAME, D.LOC
FROM EMP &quot;E&quot;
JOIN &quot;DEPT&quot;
ON E.DEPTNO = D.DEPTNO;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 경우 JOIN 키워드를 사용하여 DEPT 테이블을 불러온 후 , ON 키워드를 사용하여 공통된 컬럼인 DEPTNO를 ‘=’ 연산자로 연결해주어 각 테이블을 연동시킨다. FROM과 JOIN에 작성한 테이블의 별칭을 정해주면 테이블.컬럼명을 통해 같은 컬럼이라도 구분할 수 있게 문장을 작성할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;SELF JOIN : 자기 자신의 테이블을 조인하는 방법이다. 오라클DB 특성상 자기 자신의 DB를 FROM문에서 2번 작성하는 것이 불가능하기 때문에 셀프조인을 사용한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;SELECT E1.ENAME, E1.JOB, E2.ENAME &quot;MANAGER&quot;
FROM EMP &quot;E1&quot;
JOIN EMP &quot;E2&quot; ON E1.MGR = E2.ENAME
WHERE E1.JOB = 'CLERK';
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 직무가 ‘CLERK’인 직원의 관리자 이름을 알고 싶을 때 어떻게 해야할까? 각 직원의 관리자는 사번으로 되어있어 이름을 알기가 힘들다. 따라서 셀프조인을 통해 E1의 MGR과 E2의 ENAME을 연결시켜서 사번 대신에 관리자의 이름이 나오도록 설정하는 것이 가능하다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;OUTER JOIN : 2개 이상의 테이블이 조인이 될 때 어느 한 쪽 테이블에는 해당하는 데이터가 다른쪽 테이블에 존재하지 않을 경우 그 데이터가 출력되지 않을 수 있다. 따라서, 정보가 부족한 테이블의 칼럼 뒤에 ‘(+)’ 기호를 붙여서 데이터가 출력되도록 할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;SELECT E1.ENAME &quot;NAME&quot; , E2.ENAME &quot;MANAGER&quot; FROM EMP &quot;E1&quot; JOIN EMP &quot;E2&quot; ON E1.MGR = E2.EMPNO(+);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EMP의 관리자와 사번을 조인하려고 한다. 근데 직원 중에 CEO 직급인 KING 사원의 경우에는 관리자가 없어서 데이터 값이 NULL이다. 이 경우, 출력이 되지 않는다. 따라서 EMPNO에 (+)기호를 달아서 NULL 값인 데이터도 출력이 되도록 하였다.&lt;/p&gt;

&lt;h1 id=&quot;dual-table--오라클에서-제공하는-함수&quot;&gt;DUAL TABLE : 오라클에서 제공하는 함수&lt;/h1&gt;

&lt;p&gt;DUAL TABLE에는 오라클에서 제공하는 함수들을 사용할 수 있다. 간단하게 함수를 만들어서 사용할 수 있는 하나의 행, 하나의 컬럼만들 담고있는 테이블로, 계산 및 데이터를 가공하기 위해서 사용되는 함수이다.&lt;/p&gt;

&lt;h2 id=&quot;날짜와-관련된-함수&quot;&gt;날짜와 관련된 함수&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;SYSDATE : 현재 시스템의 날짜를 불러온다. 오라클 DB에서는 날짜 간에 +,-를 통한 연산이 가능한데, +는 다음 날짜, -는 이전 날짜로 계산이 되어진다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ADD_MONTHS(DATE, MONTH) : DATE 자료형에 월 을 더할 수 있는 함수이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;NEXT_DAY(DATE, ‘요일’) : DATE 데이터를 기준으로 요일을 체크하여 요일이 지났으면 다음주 요일, 지나지 않았으면 이번주 요일을 DATE 형식으로 표기한다. 한국어로 설정되어있어서 그런지 ‘요일’은 한글로 입력해야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LAST_DAY(DATE) : 달의 마지막 날을 구해주는 함수이다. DATE 자료형을 넣어주면 그 달의 마지막 날을 출력하여 보여준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MONTHS_BETWEEN() : 두 날짜 사이의 개월 수 차이를 구하는 함수이다. 계산이 되면 일 단위로 출력되며, 뒤에 무수히 많은 소수점이 출력되는 것으로 보아 시간 단위까지 계산이 되는 것으로 보인다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TO_CHAR() : 형식에 맞게 문자열로 날짜를 출력할 수 있도록 해주는 함수이다. WINDOW에서는 기본적으로 YY/MM/DD 형식으로 되어있는데, 이 형식을 다른 형식으로 바꿀 수 있다.&lt;/p&gt;

    &lt;p&gt;SELECT TO_CHAR(SYSDATE, ‘yyyy-MM-dd’) FROM DUAL;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;현재 날짜를 ‘yyyy-MM-dd’ 형식으로 바꾼다.&lt;/p&gt;

&lt;h2 id=&quot;문자와-관련된-함수&quot;&gt;문자와 관련된 함수&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;UPPER(), LOWER(), INITCAP() : 영문자에 사용되는 함수, 대문자, 소문자로 바꿀 수 있는 함수이며 INITCAP() 함수와 같은 경우 첫 영문자만 대문자로 바뀌고 나머지는 강제로 소문자로 바뀐다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LENGTH(), LENGTHB() : 문자의 길이를 구하는 함수이다. LENGTH()는 자바에서도 많이 사용한 메소드인데, 단순히 문자의 길이를 구하기 때문에 이해가 빨리 될 것이고, LENGTHB() 함수는 문자의 바이트 수를 구하는 함수이다. 보통 한글은 한 글자에 2바이트로 계산이 되고, 숫자나 영문자는 1바이트로 계산이 된다.
단, 인코딩방식이 UTF-8인 경우에는 3씩 바이트가 잡히니, 유념해야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CONCAT(), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;||&lt;/code&gt; : 문자열을 연결해주는 함수이다. 보통 CONCAT() 보다는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;||&lt;/code&gt; 가 범용성이 더 좋기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;||&lt;/code&gt;를 더 많이 사용한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LPAD(‘STR’, ‘전체자릿수’, ‘늘어난 자릿수에 채울 문자’), RPAD() : 문자의 자릿수를 늘려주는 함수이다. LPAD는 왼쪽, RPAD는 오른쪽의 자릿수를 늘린다. 문자열이나 컬럼을 매개값으로 넣어주고, 늘릴 자릿수와 늘어난 자릿수에 채울 문자를 써주면 되는데, 데이터의 자릿수를 강제로 맞추기 때문에 자릿수에 채워줄 문자를 적어주는 것이 좋다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;  SELECT LPAD(ENAME, 10, '\*') FROM EMP;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;ENAME 컬럼의 자릿수를 10자리로 설정, 왼쪽부터 빈 값은 ‘*‘로 채운다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;  SELECT RPAD(ENAME, 10, '1234567890') FROM EMP;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ENAME 컬럼의 자릿수를 10자리로 설정, 오른쪽부터 빈 값은 ‘123456789’로 채운다. 예를 들어 빈 값이 3자리일 경우 ‘123’만 채워지는 방식이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LTRIM(), RTRIM() : 문자를 지워주는 함수이다. 왼쪽 오른쪽 함수 2가지로 구분한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;REPLACE(컬럼/문자, 찾을문자열, 변경할문자열) : 문자열을 교체해 주는 함수이다. 컬럼에 저장되어있는 전체 데이터값중에 찾을 분자열을 변경할 문자열로 전부 바꿔주는 함수.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Achasan</name>
        
        
      </author>

      

      
        <category term="Basic" />
      

      
        <summary type="html">오라클DB 공부 20210903</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">DB 기본개념, 주요 자료형, 테이블, 제약조건, 조건절</title>
      <link href="https://achasan.github.io/database_1" rel="alternate" type="text/html" title="DB 기본개념, 주요 자료형, 테이블, 제약조건, 조건절" />
      <published>2021-09-02T00:00:00+09:00</published>
      <updated>2021-09-02T00:00:00+09:00</updated>
      <id>https://achasan.github.io/database_1</id>
      <content type="html" xml:base="https://achasan.github.io/database_1">&lt;h1 id=&quot;오라클db-공부-20210902&quot;&gt;오라클DB 공부 20210902&lt;/h1&gt;

&lt;p&gt;SQL : Structed Query Language. 사람이 원하는 바를 DBMS 프로그램에 알려주는 언어&lt;/p&gt;

&lt;p&gt;데이터 모델에는 여러가지 종류가 있다. 계층형 모델, 네트워크형 모델, 관계형 데이터 모델, 객체지향형 모델
그 중 관계형 데이터 모델을 가장 많이 사용하는데, 데이터 간의 관계에 초점을 맞춘 데이터 모델이다.&lt;/p&gt;

&lt;p&gt;예를들어 부서와 관련된 정보를 부서코드로 변환하여 모든 직원의 부서 정보를 변경해야할 경우가 있을 경우
부서 코드의 내용만 변경하여 간단하게 관리하게끔 하는 것이 관계형 데이터 모델이다.
관계형 데이터 모델은 기본키와 외래키로 구성되어있는데, 이는 나중에 설명&lt;/p&gt;

&lt;p&gt;관계형 DB의 구성요소로는 TABLE, ROW, COLUMN이 있다.
관계형 DB는 기본적으로 데이터를 2차원 표 형태로 저장하고 관리한다. 이를 TABLE이라고 한다.
TABLE은 행과 열로 구성되어있는데, 행(ROW)은 저장하려는 하나의 객체를 구성하는 값이다.
열(COLUMN)은 저장하는 데이터를 대표하는 이름과 공통특성을 정의한 것으로, 저장 정보의 종류와 자료의
저장가능한 최대크기, 중복여부를 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;오라클 세팅은 CMD를 통해서 한다.
CREATE USER (ID) IDENTIFIED BY (PW); &amp;gt; 사용자를 생성하는 것으로 DB에 엑세스하고 관리, 수정할 수 있는 사용자를 추가하는 것이다.
GRANT CONNECT, RESOURCE, DBA TO (ID) &amp;gt; 만든 ID에 데이터와 관련된 권한을 부여한다.&lt;/p&gt;

&lt;h2 id=&quot;오라클-column에-입력하는-주요-자료형data-type&quot;&gt;오라클 COLUMN에 입력하는 주요 자료형(DATA TYPE)&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;NUMBER(N, N1) : N은 전체 자릿수를 의미하고 N1은 소수 자릿수를 의미한다. N-N1은 정수 자릿수를 의미한다.
정수는 1~38자리까지 표현가능하고, 실수는 -84~127자리까지 표현이 가능하다.
예를들어, NUMBER(7,2)는 전체 7자리, 정수를 5자리, 실수를 2자리 표시할 수 있는 자료형이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CHAR(N) : 문자열이 n개 저자오디는 자료형으로, 고정자료형이다. 자릿수를 채우지 않아도 공간이 남기 때문에 비효율적이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;VARCHAR(N) : 문자열이 N개 저장되는 자료형이다. 지금은 사용하지 않는 자료형&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;VARCHAR2(N) : 문자열이 N개 저장되는 자료형으로 가변자료형이다. 쓰이지 않은 공간은 없애버리기 때문에 CHAR에 비해 효율적&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DATE : 날짜가 저장되는 자료형으로 시스템의 현재 날자 및 시간이 저장된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;db관련-개념&quot;&gt;DB관련 개념&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;무결성(INTEGRITY) : DB에 저장된 값이 실제 현실에서의 수치와 같아야하는 데이터의 특징. 결성이 없는 것.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;무결성 제약조건 : DB에 저장된 값의 정확성을 보장하기 위해 정확하지 않은 데이터의 저장을 방지하기 위한 조건을 말한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제약조건의-종류&quot;&gt;제약조건의 종류&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;UNIQUE 제약 조건 : 중복이 되면 안되는 제약조건으로, 중복이 있을 경우에는 에러가 발생한다. 단, NULL은 중복에 포함되지 않는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;NOT NULL 제약 조건 : 지정된 열에 NULL을 허용하지 않는 제약 조건, 공백을 허용하지 않는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CHECK 제약 조건 : 설정한 데이터값만 가져오게 할 수 있는 제약조건이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PRIMARY KEY 제약 조건 : UNIQUE + NOT NULL을 합친 조건이다. PRIMARY KEY는 기본키라고 불리고, 해당 테이블을 대표하는
컬럼으로서의 역할을 수행하며, 다른테이블에서 외래키들이 참조할 수 있는 키로서의 자격을 가지게 된다.
(외래키 : 컬럼이 다른 테이블에서 정의된 데이터를 참조하는 것)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;테이블&quot;&gt;테이블&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;테이블 생성 : CREATE TABLE 테이블이름(컬럼 자료형 제약조건);
한번에 여러개의 컬럼을 생성할 수 있다. 제약조건은 쓰지 않아도 생성할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;테이블에 컬럼 추가 : ALTER TABLE 테이블이름 ADD(컬럼 자료형 제약조건);&lt;/li&gt;
  &lt;li&gt;테이블 내 컬럼 수정 : ALTER TABLE 테이블이름 MODIFY(컬럼이름 자로형 제약조건);&lt;/li&gt;
  &lt;li&gt;테이블 내 컬럼명 수정 : ALTER TABLE 테이블이름 RENAME COLUMN 컬럼 TO 새이름;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;테이블 내 컬럼 삭제 : ALTER TABLE 테이블이름 DROP COLUMN 컬럼;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;테이블에 데이터 추가 : INSERT INTO 테이블이름 VALUES(컬럼1, 컬럼2, 컬럼3, … , 컬럼N);
테이블에 생성되어있는 컬럼에 데이터를 넣는다. 컬럼갯수가 맞지 않으면 뒤의 컬럼은 NULL 상태가 된다.
제약조건이 있을 경우 에러가 날 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;지정한 컬럼에만 데이터 추가 : INSERT INTO 테이블이름(컬럼1, 컬럼2, 컬럼3, 컬럼4, … , 컬럼N)
VALUES(컬럼데이터1, 컬럼데이터2, 컬럼데이터3, 컬럼데이터4, … , 컬럼데이터N);
테이블이름 뒤에 소괄호로 컬럼을 작성하고 VALUES 뒤에 컬럼과 관련된 데이터를 작성하는 방식
테이블 이름 뒤에 작성한 컬럼과 형식이 동일한 자료형을 입력해야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;테이블의 데이터 값 수정 : UPDATE, SET 사용
UPDATE 테이블이름 SET 컬럼 = 데이터값 WHERE 조건에 맞는 행
조건에 맞는 행은 기본값을 써주어도되고, 원하는 행에 해당하는 데이터 값을 조건으로 맞춰주면된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;특정 데이터 행 삭제 : DELETE FROM 테이블 WHERE 조건식;
조건식에 맞는 행을 테이블에서 제거한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;null값을-가진-데이터와-연신-시에는-null값이-출력된다&quot;&gt;NULL값을 가진 데이터와 연신 시에는 NULL값이 출력된다.&lt;/h3&gt;

&lt;p&gt;따라서 NULL값을 가진 데이터와 연산 시에는 NULL값을 특정값으로 변경하는 함수를 사용해야하는데
NVL() 함수를 통해서 사용할 수 있다. NVL() 함수를 통해 연산 시에는 자료형을 일치시켜주어야 한다.&lt;/p&gt;

&lt;p&gt;NVL(NULL값이 있는 칼럼, 변경 값);&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NVL2() : JAVA의 삼항연산자와 사용방법이 비슷하다. NVL2(컬럼명, EXPR1, EXPR2)
NULL이 아닌 경우 EXPR1을 출력하고, NULL인 경우에는 EXPR2를 출력한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;컬럼에-별칭-부여&quot;&gt;컬럼에 별칭 부여&lt;/h2&gt;

&lt;p&gt;여러 데이터를 가지고 연산을 하면 연산된 칼럼의 이름을 수정해주어야 하는데, 이를 컬럼에 별칭을 준다고 한다.
연산한 컬럼, 또는 함수를 사용한 컬럼 되에 AS 키워드를 쓰고, 그 뒤에 “별칭”을 작성하면 된다.
EX) SELECT NVL(SAL, 0) AS “SAL” FROM EMP;&lt;/p&gt;

&lt;h2 id=&quot;중복을-제거해주는-함수--distinct&quot;&gt;중복을 제거해주는 함수 : DISTINCT&lt;/h2&gt;

&lt;p&gt;SELECT 바로 뒤에 쓰여야하는 함수로, 중복된 값을 제거하고 하나만 출력하는 함수이다.&lt;/p&gt;

&lt;h2 id=&quot;literal-작업--&quot;&gt;LITERAL 작업 : ||&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;||&lt;/code&gt; 를 사용하여 데이터를 문자열과 연결하여 출력할 수 있다. 이는 CONCAT() 함수와 같은 기능이지만
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;||&lt;/code&gt; 가 편하기 때문에 더 많이 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;where-조건절--작성한-조건식에-맞는-데이터를-필터링&quot;&gt;WHERE 조건절 : 작성한 조건식에 맞는 데이터를 필터링&lt;/h2&gt;

&lt;p&gt;WHERE 조건절에 사용할 수 있는 연산자가 다양하게 존재한다.
JAVA에서 비교연산자는 익숙해서 SQL에서 사용하는 연산자를 알아보았다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;BETWEEN a AND b : A와 B 사이에 있는 범위 값을 모두 검색한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IN(a, b, c) : A이거나 B이거나 C인 조건을 검색한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LIKE : 특정 패턴을 가지고 있는 조건을 검색한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IS NULL / IS NOT NULL : NULL값을 검색 / NULL이 아닌 값을 검색&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A AND B : A조건과 B 조건을 모두 만족하는 값을 검색(A와 B는 조건이 들어간다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A OR B : A 조건이나 B 조건 중 한 가지라도 만족하는 값을 검색한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;NOT A : A가 아닌 모든 조건을 검색한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 LIKE 연산자를 어떻게 사용하는지가 궁금하였는데 %와 _를 사용하여 비슷한 데이터값들을 찾을 수 있는 연산자이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;% : 글자 수에 제한이 없고 어떤 글자가 와도 상관없는 경우&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;_ : 글자 수는 한 글자만 올 수 있고 어떤 글자가 와도 상관없는 경우&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;EX) WHERE SAL LIKE ‘1%’ : SAL 컬럼에서 앞자리가 1인 데이터를 출력, 뒤에는 어떤 수가 와도 상관없다.&lt;/li&gt;
  &lt;li&gt;EX) WHERE HIREDATE LIKE *__12% : 입사일이 12월인 직원의 데이터를 출력하고 싶을 때 *를 사용한다.
DATE 자료형의 형식은 YY/MM/DD 이므로, YY/ 뒤의 두 자리가 월 이므로,
12를 썼고, 뒤에는 아무내용이나 와도 상관없으므로 %를 사용.&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Achasan</name>
        
        
      </author>

      

      
        <category term="Basic" />
      

      
        <summary type="html">오라클DB 공부 20210902</summary>
      

      
      
    </entry>
  
</feed>
