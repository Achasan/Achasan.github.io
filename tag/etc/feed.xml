<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://achasan.github.io/tag/etc/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://achasan.github.io/" rel="alternate" type="text/html" />
  <updated>2021-12-31T14:02:59+09:00</updated>
  <id>https://achasan.github.io/tag/etc/feed.xml</id>

  
  
  

  
    <title type="html">Memory Repo. | </title>
  

  
    <subtitle>by Achasan</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">객체지향의 사실과 오해 1장 정리</title>
      <link href="https://achasan.github.io/OOP_1" rel="alternate" type="text/html" title="객체지향의 사실과 오해 1장 정리" />
      <published>2021-12-22T00:00:00+09:00</published>
      <updated>2021-12-22T00:00:00+09:00</updated>
      <id>https://achasan.github.io/OOP_1</id>
      <content type="html" xml:base="https://achasan.github.io/OOP_1">&lt;h1 id=&quot;객체지향의-사실과-오해-1장-정리&quot;&gt;객체지향의 사실과 오해 1장 정리&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ObjectOrientation.png&quot; alt=&quot;book&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;시너지를 생각하라, 전체는 부분의 합보다 크다. - 스티븐 코비&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;협력하는-객체들의-공통체&quot;&gt;협력하는 객체들의 공통체&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;1장에서는 지금까지 설명해온 객체지향의 개념을 부정하며 시작한다.&lt;/li&gt;
  &lt;li&gt;객체지향 소프트웨어는 실세계의 투영, 객체란 현실 세계에 존재하는 사물에 대한 추상화이지만 이는 철학적인 개념&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;실용적인 관점에서는 설명하기에 적합하지 않다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;객체지향의 목표는 실세계를 모방하는 것이 아닌 새로운 세계를 창조하는 것&lt;/li&gt;
  &lt;li&gt;하지만 실세계의 비유가 객체지향의 다양한 측면을 이해하고 학습하는데 효과적&lt;/li&gt;
  &lt;li&gt;실세계로 객체지향을 설명해야 핵심 사상인 &lt;strong&gt;연결안정성&lt;/strong&gt;을 설명하는데 적합한 틀 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;협력하는-사람들&quot;&gt;협력하는 사람들&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;한 에피소드를 이야기하며 시작.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;커피를 마시고 싶은 손님이 커피를 주문하기위해 캐시어한테 커피를 주문, 점원은 바리스타에게 커피를 한 잔 달라고 요청, 만들어진 커피는 손님에게 전달됨.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;손님이 커피를 마시기까지의 과정에 암묵적인 &lt;strong&gt;협력&lt;/strong&gt;관계가 숨어있음.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;손님, 캐시어, 바리스타는 자신이 맡은 &lt;strong&gt;역할&lt;/strong&gt;이 있으며, 이를 성실히 수행하기위해 &lt;strong&gt;책임&lt;/strong&gt;을다한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사람이 사는 곳이라면 어디서나 &lt;strong&gt;역할, 책임, 협력&lt;/strong&gt;이 존재하며 이는 객체지향에서 가장 중요한 개념 세 가지가 된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;요청과-응답으로-구성된-협력&quot;&gt;요청과 응답으로 구성된 협력&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;사람은 스스로 해결하지 못하는 문제와 마주치면 다른 사람에게 도움을 &lt;strong&gt;요청(request)&lt;/strong&gt; 한다. 문제의 규모가 클 수록 요청은 연쇄적으로 발생하게된다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;손님은 커피를 못 만드므로 커피를 캐시어에게 요청한다.&lt;/li&gt;
      &lt;li&gt;캐시어는 주문을 받고 바리스타에게 커피를 만들도록 요청한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;요청을 받은 사람은 주어진 책임을 다하며 다른사람의 요청에 &lt;strong&gt;응답(response)&lt;/strong&gt; 한다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;바리스타는 캐시어의 요청을 받고 커피를 만든다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;캐시어는 바리스타로 부터 만들어진 커피를 받고, 손님의 요청에 응답한다.(전달)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위의 과정을 통해 다른사람과 &lt;strong&gt;협력(collaboration)&lt;/strong&gt; 할 수 있는 능력은 거대하고 복잡한 문제를 해결할 수 있는 공통를 생성시킨다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;역할과-책임&quot;&gt;역할과 책임&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;협력하는 과정 속에서 특정한 역할을 부여받게된다. 위의 과정에서는 손님, 캐시어, 바리스타라는 역할이 존재한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;여기서 역할은 책임이라는 개념을 내포한다. 경찰이 범죄자를 잡아야하는 책임, 선생님이 제자를 가르쳐야하는 책임이 있는 것처럼 말이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;역할을 맡고, 적합한 책임을 수행하는 것은 몇 가지 중요한 개념을 제시한다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;여러 사람이 동일한 역할을 수행할 수 있다.&lt;/li&gt;
      &lt;li&gt;역할은 대체 가능성을 의미한다.&lt;/li&gt;
      &lt;li&gt;책임을 수행하는 방법은 자율적으로 선택할 수 있다.&lt;/li&gt;
      &lt;li&gt;한 사람이 동시에 여러 역할을 수행할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;역할-책임-협력&quot;&gt;역할, 책임, 협력&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;손님, 캐시어, 바리스타가 가지고 있던 역할과 책임을 객체지향적으로 바꾸어보자.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사람이라는 단어를 객체로, 요청을 메시지로, 요청을 처리하는 방법을 메서드로 바꾸면 객체지향의 문맥으로 옮길 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사람들이 타인과 관계를 맺고, 협력하는 과정이 객체지향과 근본개념과 유사하다는 사실을 공감할 수 있게된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;역할과-책임을-수행하며-협력하는-객체들&quot;&gt;역할과 책임을 수행하며 협력하는 객체들&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;협력의 핵심은 특정한 책임을 수행하는 역할을 간의 연쇄적인 요청과 응답을 통해 목표를 달성한다는 것이다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;목표의 규모가 커질 수록 목표는 작은 단위로 쪼개지게되며, 하나의 단위에 적합한 사람이 역할을 수행하게되면서 요청과 응답은 연쇄되어 하나의 목표를 달성한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;객체의 경우 애플리케이션의 기능을 구현하기위해 협력하게된다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;하나의 시스템은 역할과 책임을 수행하는 객체로 분할되고, 시스템의 기능은 객체 간의 연쇄적인 요청과 응답의 흐름으로 구성된 협력으로 구현된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;객체의 역할은 사람의 역할과 유사하게 다음과 같은 특징을 지닌다.
    &lt;ul&gt;
      &lt;li&gt;여러 객체가 동일한 역할을 수행&lt;/li&gt;
      &lt;li&gt;역할은 대체 가능성을 의미&lt;/li&gt;
      &lt;li&gt;각 객체는 책임을 수행하는 방법을 자율적으로 선택&lt;/li&gt;
      &lt;li&gt;하나의 객체가 동시에 여러 역할을 수행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;협력-속에-사는-객체&quot;&gt;협력 속에 사는 객체&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;역할, 책임, 협력에 참여하는 주체는 객체이다. 협력 공동체의 일원으로서 객체는 두 가지의 덕목을 갖추어야 한다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;객체는 충분히 협력적이어야한다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;다른 객체의 요청에 귀 기울이고, 적극적으로 도움을 요청하는 열린 마음&lt;/li&gt;
          &lt;li&gt;모든 것을 스스로 처리하는 객체는 자멸하고만다.&lt;/li&gt;
          &lt;li&gt;수동적이어야한다는 의미가 아니다. 어떤 방식으로 처리할지는 객체 스스로가 결정해야한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;객체는 충분히 자율적이어야한다.&lt;/p&gt;
        &lt;ul&gt;
          &lt;li&gt;‘자기 스스로의 원칙에 따라 어떤 일을 하거나 통제하여 절제하는 것’&lt;/li&gt;
          &lt;li&gt;요청에 의해 역할을 수행하지만 방식은 스스로의 판단에 따라 결정하고 행동한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;객체지향 설계의 묘미는 다른 객체와 조화롭게 협력하는만큼 개방적인 동시에 참여하는 방법을 스스로 결정할 수 있는 자율적인 객체들의 공동체를 설계하는데 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;상태와-행동을-함께-지닌-자율적인-객체&quot;&gt;상태와 행동을 함께 지닌 자율적인 객체&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;객체를 상태(state)와 행동(behavior)을 함께 지닌 실체로 정의&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;객체의 자율성은 객체의 내부와 외부를 명확히 구분하는 것&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;객체의 사적인 부분은 스스로 관리하고 외부에서 간섭할수 없어야한다.&lt;/li&gt;
      &lt;li&gt;외부에서는 접근이 허락된 수단을 통해서만 객체와 의사소통&lt;/li&gt;
      &lt;li&gt;무엇(what)을 수행하는지는 알 수 있지만 어떻게(how) 수행하는지에 대해서는 알 수 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;전통적인 개발방법과 객체지향의 개발방법을 구분짓는 가장 핵심적인 차이이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;협력과-메시지-메서드와-자율성&quot;&gt;협력과 메시지, 메서드와 자율성&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;객체는 메시지로 의사소통한다. 메시지를 전송하고 수신하며 소통한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;객체지향의 세계에서 협력은 메시지를 전송하는 객체와 메시지를 수신하는 객체 사이의 관계로 구성된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메시지를 수신하는 객체는 메시지를 이해할 수 있는지 판단하고, 자신만의 방법에 따라 메시지를 처리한다. 이를 메서드라고 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메시지와 메서드의 분리는 객체들 간의 자율성을 증진시킨다. 메시지에 응답하기위해 여러가지 메서드를 사용할 수 있게 되는 것이다. 이것은 &lt;strong&gt;캡슐화&lt;/strong&gt;라는 개념과 깊이 관련되어 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Achasan</name>
        
        
      </author>

      

      
        <category term="ETC" />
      

      
        <summary type="html">객체지향의 사실과 오해 1장 정리</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">AJAX를 사용하여 아이디 중복체크하기</title>
      <link href="https://achasan.github.io/ajax_id_distinct" rel="alternate" type="text/html" title="AJAX를 사용하여 아이디 중복체크하기" />
      <published>2021-11-07T00:00:00+09:00</published>
      <updated>2021-11-07T00:00:00+09:00</updated>
      <id>https://achasan.github.io/ajax_id_distinct</id>
      <content type="html" xml:base="https://achasan.github.io/ajax_id_distinct">&lt;h1 id=&quot;ajax-사용하여-아이디-중복체크하기스프링부트&quot;&gt;AJAX 사용하여 아이디 중복체크하기(스프링부트)&lt;/h1&gt;

&lt;p&gt;곧 JSP 프로젝트가 시작된다. 시작하기 전에 AJAX에 대해 알아보고 어떻게 사용하는지 익히기 위해서 글을 작성하였다.&lt;/p&gt;

&lt;p&gt;AJAX의 개념적인 부분은 이미 구글링을 하면 다 나와있기에 여기서 자세히 설명하지는 않을 것이다. 이 글에서는 AJAX를 통해 아이디 중복확인을 하는 로직을 간단하게 구현하는 방법에 대해서 초점을 맞출 생각이다.&lt;/p&gt;

&lt;p&gt;일단 DB연동같은건 하지 않았다. 그냥 Controller에 String 배열로 임의의 아이디 여러 개를 생성해놓고, 클라이언트가 ID를 입력할 때 String 배열에 있는 값과 일치할 경우 실행될 로직을 작성해보았다. 스프링 부트로 구현해보았다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;test.html&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ETC/2021-11-07-22-11-41.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그냥 아이디와 비밀번호가 존재하는 단순한 HTML 파일이다. input 입력란 옆에 span태그를 숨겨놓고 텍스트를 입력할 때 로직이 실행되도록 했다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;JavaScript&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ETC/2021-11-07-22-21-40.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;로직을 요약하자면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;먼저 span 태그를 숨긴다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;아이디 input 태그에 아이디를 입력할 때마다 함수가 실행되는 keyup을 사용하였다. 텍스트 길이가 4미만 또는 16 이상일 때 span 태그로 조건에 만족하지 않는 멘트를 날리도록 코드를 작성했다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;만약 길이가 4 이상 16 이하라면 ajax로 서버와 통신한다. post방식으로 입력한 아이디를 서버로 전송하고, url은 “/id-check”으로 설정한다. 받는 데이터 타입은 간단하게 text로 하였다. json형식으로도 받을 수 있고, 스프링부트에서 json으로 데이터를 반환하는 기능들을 지원하지만 간단하게 구현하기위해 text로 하였다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;success는 데이터를 성공적으로 받았을 때 실행되는 함수이다. 받은 데이터가 false이면 사용가능한 아이디, true이면 이미 사용중인 아이디라고 멘트가 나오도록 했다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;처음 사용할 때는 삽질을 엄청했다. 특히 데이터를 넘기는 부분. 사실 ajax를 처음 쓴다기 보다는 jQuery가 익숙치 않아서 삽질이 길어진 것 같다. 데이터를 넘길 때는 data에 값을 넣고, 데이터를 받을 때는 success의 function 파라미터로 받아오기 때문에 이 부분을 정확히 모르는 상태에서 사용하다 시간이 길어졌다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Controller&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ETC/2021-11-07-22-24-25.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;먼저 이미 등록된 아이디를 ids 배열에 저장했다(임의로 작성). 입력한 아이디가 ids에 있는 아이디와 일치할 경우 이미 사용중인 아이디가 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AJAX의 url을 “/id-check”으로 설정했다. @PostMapping(“/id-check”)으로 데이터가 들어오게 되고, 여기서 로직이 실행된다. @RequestParam으로 입력값을 받아오도록 했다. AJAX부분을 보면 JSON 형식으로 key는 id, value는 입력값으로 되어있었다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ids 배열을 for문으로 돌려서 만약 입력값과 일치하는 아이디가 나오면 아이디가 중복되므로 리턴할 isDistinct 변수를 true로 설정한다. 아닐 경우는 false로 설정한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 부분이 제일 스트레스 받았던 구간, 아직 스프링 부트를 배운지 얼마 안됐고, @RequestBody와 @RequestParam이 헷갈려서 데이터 값이 이상하게 오는 줄도 모르고 다른 코드를 고치고 있었다.&lt;/p&gt;

&lt;p&gt;@RequestBody는 GET이나 POST 방식이 아닐 때 사용해야하는 애노테이션이다. 정확히 말하면 쿼리파라미터로 오는 데이터가 아닐 때 사용해야한다. 모델 객체를 사용할 때 사용하는 것이 좋다. 모델 객체의 필드변수와 읽어오는 데이터의 key 값이 일치하면 모델 객체로 바인딩을 해주는 방식인데, 이를 깜빡하고 @RequestBody를 사용해서 시간이 엄청 오래걸렸다.&lt;/p&gt;

&lt;p&gt;@RequestParam은 쿼리파라미터로 값을 가져올 때 사용한다. AJAX로 보내는 값의 key가 id이므로 메서드 파라미터의 변수명도 id로 일치시키면 스프링부트는 둘의 이름이 같으므로 바인딩을 하게된다. 따라서 Model 객체가 아닌 이상은 @RequestBody를 사용하는 것이 좋다.&lt;/p&gt;

&lt;p&gt;@ModelAttribute 애노테이션도 있다. 하지만 이 애노테이션은 쿼리파라미터를 받을 때 사용하는 Model 객체이므로 여기서는 예외.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;결과&quot;&gt;결과&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ETC/result.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로젝트를 한다면 정규식으로 아이디 양식을 제한하는 코드를 만들어보고 싶다. 일단 AJAX의 기본적인 기능에 대해서 알 수 있었으므로 만족한다. 비동기로 기능을 구현하는게 굉장히 편한 것 같다. 나중에는 게시판 페이징을 비동기로 이동하는 것도 구현해보고 싶은 생각이 든다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Achasan</name>
        
        
      </author>

      

      
        <category term="ETC" />
      

      
        <summary type="html">AJAX 사용하여 아이디 중복체크하기(스프링부트)</summary>
      

      
      
    </entry>
  
</feed>
